{"version":3,"file":"component---src-templates-article-page-jsx-content-file-path-home-runner-work-leobang-17-github-io-leobang-17-github-io-documents-web-http를-stateful하게-jwt-md-3d20ed7ee8b4d9978298.js","mappings":"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","sources":["webpack://gatsby-theme-simplex/./documents/Web/http를-stateful하게-jwt.md","webpack://gatsby-theme-simplex/./src/templates/ArticlePage.jsx"],"sourcesContent":["/*@jsxRuntime classic @jsx React.createElement @jsxFrag React.Fragment*/\nimport {useMDXComponents as _provideComponents} from \"@mdx-js/react\";\nimport React from \"react\";\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    blockquote: \"blockquote\",\n    strong: \"strong\",\n    code: \"code\",\n    h5: \"h5\",\n    a: \"a\",\n    div: \"div\",\n    ul: \"ul\",\n    li: \"li\",\n    ol: \"ol\"\n  }, _provideComponents(), props.components);\n  return React.createElement(React.Fragment, null, React.createElement(_components.p, null, \"HTTP의 인증 state를 유지하기 위한 방식하면 꼭 등장하는 셋이 cookie, session 그리고 JWT이다. 사실 JWT 그 자체가 HTTP를 stateful하게 만들어 준다기 보다는 그냥 HTTP 표준의 authorization header에 token 기반으로 인가 state를 유지하는 방식 중, JWT 표준을 따르는 token을 이용한 것 뿐이지만…\"), \"\\n\", React.createElement(_components.blockquote, null, \"\\n\", React.createElement(_components.p, null, \"Base64URL인코딩된 JSON 객체를 토큰으로 이용하는 표준을 JWT라고 한다.\"), \"\\n\"), \"\\n\", React.createElement(_components.p, null, React.createElement(_components.strong, null, \"JWT가 Base64url 인코딩을 이용하는 이유\")), \"\\n\", React.createElement(_components.p, null, \"Base64 인코딩의 경우 \", React.createElement(_components.code, null, \"“+”, “/”, “=”\"), \"이 포함되지만 JWT는 URI에서 파라미터로 사용할 수 있도록 URL-Safe 한 Base64url 인코딩을 사용한다.\"), \"\\n\", React.createElement(_components.h5, {\n    id: \"jwt는-그-자체로-암호화되어있다\",\n    style: {\n      position: \"relative\"\n    }\n  }, React.createElement(_components.a, {\n    href: \"#jwt%EB%8A%94-%EA%B7%B8-%EC%9E%90%EC%B2%B4%EB%A1%9C-%EC%95%94%ED%98%B8%ED%99%94%EB%90%98%EC%96%B4%EC%9E%88%EB%8B%A4\",\n    \"aria-label\": \"jwt는 그 자체로 암호화되어있다 permalink\",\n    className: \"header-links before\"\n  }, React.createElement(_components.div, {\n    dangerouslySetInnerHTML: {\n      __html: \"<svg aria-hidden=\\\"true\\\" focusable=\\\"false\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg>\"\n    }\n  })), \"JWT는 그 자체로 암호화되어있다?\"), \"\\n\", React.createElement(_components.p, null, \"ㄴㄴ JWT는 그냥 인코딩된 문자열일 뿐이다. 이를 올바른 방식으로 디코딩한다면 누구나 내용물을 볼 수 있다. 따라서 민감한 정보를 그대로 JWT payload에 담아서 주고 받으면 안된다.\"), \"\\n\", React.createElement(_components.p, null, \"cookie 탈취를 통해 해당 토큰을 얻게된다면, 단순히 디코딩하는 것 만으로도 안의 정보를 확인할 수 있다···\"), \"\\n\", React.createElement(_components.h5, {\n    id: \"jwt의-구조\",\n    style: {\n      position: \"relative\"\n    }\n  }, React.createElement(_components.a, {\n    href: \"#jwt%EC%9D%98-%EA%B5%AC%EC%A1%B0\",\n    \"aria-label\": \"jwt의 구조 permalink\",\n    className: \"header-links before\"\n  }, React.createElement(_components.div, {\n    dangerouslySetInnerHTML: {\n      __html: \"<svg aria-hidden=\\\"true\\\" focusable=\\\"false\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg>\"\n    }\n  })), \"JWT의 구조\"), \"\\n\", React.createElement(_components.p, null, \"Header, Payload (= claim), signature로 이루어져 있다. 각 part는 \", React.createElement(_components.code, null, \".\"), \"으로 구분된다.\"), \"\\n\", React.createElement(_components.p, null, \"Header\"), \"\\n\", React.createElement(_components.ul, null, \"\\n\", React.createElement(_components.li, null, \"해당 토큰(문자열)이 JWT 형식임을 표기\"), \"\\n\", React.createElement(_components.li, null, \"어떤 알고리즘을 이용해 signature를 작성했는지 표기\"), \"\\n\"), \"\\n\", React.createElement(_components.p, null, \"Payload\"), \"\\n\", React.createElement(_components.ul, null, \"\\n\", React.createElement(_components.li, null, \"주고 받아야할, JWT가 담고 있는 정보들을 때려박는다.\"), \"\\n\", React.createElement(_components.li, null, \"RFC에 지정된 표준 claim도 있지만 원하는 key value로 claim을 전달해도 된다.\"), \"\\n\", React.createElement(_components.li, null, \"payload가 비대해질 수록 암/복호화에 시간이 오래걸리므로 필요한 정보만 담도록 하자.\"), \"\\n\"), \"\\n\", React.createElement(_components.p, null, \"Signature\"), \"\\n\", React.createElement(_components.ul, null, \"\\n\", React.createElement(_components.li, null, \"Header와 Payload의 값을 특정 암호화 알고리즘 + secret key를 활용해 암호화한 것.\"), \"\\n\", React.createElement(_components.li, null, \"해시 알고리즘이기 때문에 header 혹은 payload의 조작 여부를 확인할 수 있다.\"), \"\\n\", React.createElement(_components.li, null, \"대칭키와 비대칭키 암호화 방식을 모두 이용 가능하다.\"), \"\\n\"), \"\\n\", React.createElement(_components.h5, {\n    id: \"대칭키-암호화-비대칭키-암호화\",\n    style: {\n      position: \"relative\"\n    }\n  }, React.createElement(_components.a, {\n    href: \"#%EB%8C%80%EC%B9%AD%ED%82%A4-%EC%95%94%ED%98%B8%ED%99%94-%EB%B9%84%EB%8C%80%EC%B9%AD%ED%82%A4-%EC%95%94%ED%98%B8%ED%99%94\",\n    \"aria-label\": \"대칭키 암호화 비대칭키 암호화 permalink\",\n    className: \"header-links before\"\n  }, React.createElement(_components.div, {\n    dangerouslySetInnerHTML: {\n      __html: \"<svg aria-hidden=\\\"true\\\" focusable=\\\"false\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg>\"\n    }\n  })), \"대칭키 암호화? 비대칭키 암호화?\"), \"\\n\", React.createElement(_components.p, null, \"토큰 위/변조만 필요하다면 대칭키 암호화 알고리즘으로도 충분하다. 만약 디지털 서명이 필요하다면 비대칭키 방식을 활용해야겠지만, 비대칭키는 암/복호화에 더욱 많은 CPU 타임을 소모한다 = 느리다.\"), \"\\n\", React.createElement(_components.h5, {\n    id: \"jwt의-장점\",\n    style: {\n      position: \"relative\"\n    }\n  }, React.createElement(_components.a, {\n    href: \"#jwt%EC%9D%98-%EC%9E%A5%EC%A0%90\",\n    \"aria-label\": \"jwt의 장점 permalink\",\n    className: \"header-links before\"\n  }, React.createElement(_components.div, {\n    dangerouslySetInnerHTML: {\n      __html: \"<svg aria-hidden=\\\"true\\\" focusable=\\\"false\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg>\"\n    }\n  })), \"JWT의 장점\"), \"\\n\", React.createElement(_components.ol, null, \"\\n\", React.createElement(_components.li, null, \"I/O 타임을 줄일 수 있다.\"), \"\\n\"), \"\\n\", React.createElement(_components.p, null, \"일단 Session은 서버 애플리케이션이 하나의 instance에서만 실행되는게 아니라면, 애플리케이션 프로세스 외부의 DB 서버를 바라보고 있을 것이다. 혹은 session affinity 설정을 통해 애플리케이션 프로세스 안에서 해결할 수도···!\"), \"\\n\", React.createElement(_components.p, null, \"어쨌든 session DB가 InMemory DB던 SSD까지 접근하는 DB던 네트워크 I/O가 발생하고, 특정 DB에 부하를 주는 것이므로 부담이 되는 일이다.\"), \"\\n\", React.createElement(_components.ol, {\n    start: \"2\"\n  }, \"\\n\", React.createElement(_components.li, null, \"대칭키 암호화는 비교적 빠른 편이다.\"), \"\\n\"), \"\\n\", React.createElement(_components.p, null, \"암/복호화 이후에는 claim에 대한 값 검증만 수행하면 된다. 이 과정은 꽤 빠르게 이루어질 수 있다.\"), \"\\n\", React.createElement(_components.ol, {\n    start: \"3\"\n  }, \"\\n\", React.createElement(_components.li, null, \"Server는 Stateless를 획득할 수 있다.\"), \"\\n\"), \"\\n\", React.createElement(_components.p, null, \"이용자에 대한 상태를 저장해둘 필요가 없다.\"), \"\\n\", React.createElement(_components.h5, {\n    id: \"jwt의-단점\",\n    style: {\n      position: \"relative\"\n    }\n  }, React.createElement(_components.a, {\n    href: \"#jwt%EC%9D%98-%EB%8B%A8%EC%A0%90\",\n    \"aria-label\": \"jwt의 단점 permalink\",\n    className: \"header-links before\"\n  }, React.createElement(_components.div, {\n    dangerouslySetInnerHTML: {\n      __html: \"<svg aria-hidden=\\\"true\\\" focusable=\\\"false\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg>\"\n    }\n  })), \"JWT의 단점\"), \"\\n\", React.createElement(_components.ol, null, \"\\n\", React.createElement(_components.li, null, \"토큰이 길어 네트워크 부하를 늘린다.\"), \"\\n\"), \"\\n\", React.createElement(_components.p, null, \"Session은 네트워크 요청 시에 cookie를 이용해 session key만 주고 받는다. session key가 일반적으로 JWT보다는 길이가 짧으므로 네트워크 부하를 높인다.\"), \"\\n\", React.createElement(_components.ol, {\n    start: \"2\"\n  }, \"\\n\", React.createElement(_components.li, null, \"이미 생성한 토큰은 변경 불가능하다.\"), \"\\n\"), \"\\n\", React.createElement(_components.p, null, \"JWT는 일단 생성하면 내용물을 변경할 수 없다. 좋은 점도 있지만 문제는 이미 발급한 토큰은 만료기한 동안 쭉 활성화된 토큰이 된다.\"), \"\\n\", React.createElement(_components.p, null, \"만료기한이 1일 남은 로그인용 JWT가 존재하고, 유저가 로그아웃을 원한다. 물론 로그아웃 로직을 수행하는 방식은 클라이언트와 조율해서 간단히 구현할 수 있지만, 어쨌든 해당 토큰은 만료기한까지 이용할 수 있는 상태이다.\"), \"\\n\", React.createElement(_components.p, null, \"세션을 이용한다면 단순히 해당 세션키를 지워버리면 된다. 하지만 JWT를 진정한 의미로 ‘만료’시키려면 JWT 역시 세션으로 저장하고 해당 jwt가 만료되었는지를 체크해야할 것이다.\"), \"\\n\", React.createElement(_components.p, null, \"내부 상태를 변경하고자 하는 것 역시 문제가 된다. JWT는 변경할 수 없으므로 새로운 상태로 갱신한 JWT를 새로 발급해야하는데, 그러면 잠시동안이겠지만 한 유저에게 할당된 활성화된 토큰이 2개 이상으로 늘어나게 된다. 취약점이 산술적으로 상승하는 셈.\"), \"\\n\", React.createElement(_components.ol, {\n    start: \"3\"\n  }, \"\\n\", React.createElement(_components.li, null, \"만료기한을 매우 짧게 잡다보니 refresh 전략이 중요하다···\"), \"\\n\"));\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? React.createElement(MDXLayout, props, React.createElement(_createMdxContent, props)) : _createMdxContent(props);\n}\nexport default MDXContent;\n","import GATSBY_COMPILED_MDX from \"/home/runner/work/leobang17.github.io/leobang17.github.io/documents/Web/http를-stateful하게-jwt.md\";\nimport React from 'react';\nimport {graphql} from 'gatsby';\nimport ArticleLayout from 'components/Layout/ArticleLayout';\nimport MarkdownWrapper from 'components/MarkdownWrapper';\nimport ArticleFrontmatter from 'components/ArticleFrontmatter';\nimport ArticlePageContext from 'contexts/ArticlePageContext';\nimport Utterances from 'components/Utterance';\nimport RecentPosts from 'components/RecentPosts/RecentPosts';\nconst isBrowser = typeof window !== undefined;\nconst ArticlePage = ({data, children, serverData}) => {\n  const {prevPost, nextPost} = data;\n  const frontmatters = {\n    ...data.mdx.frontmatter,\n    timeToRead: data.mdx.fields.timeToRead\n  };\n  return React.createElement(ArticlePageContext, {\n    data: data\n  }, React.createElement(ArticleLayout, null, React.createElement(ArticleFrontmatter, frontmatters), React.createElement(MarkdownWrapper, null, children), React.createElement(RecentPosts, {\n    prev: prevPost,\n    next: nextPost\n  }), React.createElement(Utterances)));\n};\nArticlePage\nexport default function GatsbyMDXWrapper(props) {\n  return React.createElement(ArticlePage, props, React.createElement(GATSBY_COMPILED_MDX, props));\n}\nexport const query = graphql`\n  query ($id: String, $nextId: String, $prevId: String) {\n    mdx(id: { eq: $id }) {\n      id\n      fields {\n        slug\n        timeToRead\n        categoryDirectory\n      }\n      frontmatter {\n        title\n        createdAt(formatString: \"MMMM DD, YYYY\")\n      }\n      tableOfContents\n    }\n    prevPost: mdx(id: { eq: $prevId }) {\n      fields {\n        slug\n      }\n      frontmatter {\n        title\n      }\n    }\n    nextPost: mdx(id: { eq: $nextId }) {\n      fields {\n        slug\n      }\n      frontmatter {\n        title\n      }\n    }\n  }\n`;\nexport {ArticlePageHead as Head} from 'components/head';\n"],"names":["_createMdxContent","props","_components","Object","assign","p","blockquote","strong","code","h5","a","div","ul","li","ol","_provideComponents","components","React","id","style","position","href","className","dangerouslySetInnerHTML","__html","start","wrapper","MDXLayout","ArticlePage","data","children","serverData","prevPost","nextPost","frontmatters","mdx","frontmatter","timeToRead","fields","ArticlePageContext","ArticleLayout","ArticleFrontmatter","MarkdownWrapper","RecentPosts","prev","next","Utterances","GatsbyMDXWrapper","GATSBY_COMPILED_MDX"],"sourceRoot":""}