"use strict";(self.webpackChunkgatsby_theme_simplex=self.webpackChunkgatsby_theme_simplex||[]).push([[579],{6619:function(e,n,t){t.r(n),t.d(n,{Head:function(){return p.py},default:function(){return E}});var l=t(1151),r=t(7294);function a(e){const n=Object.assign({h2:"h2",a:"a",div:"div",p:"p",code:"code",h4:"h4",ul:"ul",li:"li",pre:"pre"},(0,l.ah)(),e.components);return r.createElement(r.Fragment,null,r.createElement(n.h2,{id:"문제",style:{position:"relative"}},r.createElement(n.a,{href:"#%EB%AC%B8%EC%A0%9C","aria-label":"문제 permalink",className:"header-links before"},r.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"문제"),"\n",r.createElement(n.p,null,"문자열 ",r.createElement(n.code,null,"beginWord"),"와 ",r.createElement(n.code,null,"endWord"),"가 주어진다. 문자열 배열 ",r.createElement(n.code,null,"wordList"),"를 이용해 ",r.createElement(n.code,null,"beginWord"),"에서 ",r.createElement(n.code,null,"endWord"),"까지 가고자 한다. 이동할 수 있는 조건은 두 문자열이 하나의 문자만 빼고 동일해야한다는 것이다.\n",r.createElement(n.code,null,"beginWord"),"는 ",r.createElement(n.code,null,"wordList"),"에 없을 수도 있다. ",r.createElement(n.code,null,"beginWord"),"에서 ",r.createElement(n.code,null,"endWord"),"로 가는 가장 짧은 transformation 횟수를 구하라. 만약 도달할 수 없다면 0을 반환한다."),"\n",r.createElement(n.h4,{id:"constraints",style:{position:"relative"}},r.createElement(n.a,{href:"#constraints","aria-label":"constraints permalink",className:"header-links before"},r.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Constraints"),"\n",r.createElement(n.ul,null,"\n",r.createElement(n.li,null,r.createElement(n.code,null,"1 <= beginWord.length <= 10")),"\n",r.createElement(n.li,null,r.createElement(n.code,null,"endWord.length == beginWord.length")),"\n",r.createElement(n.li,null,r.createElement(n.code,null,"1 <= wordList.length <= 5000")),"\n",r.createElement(n.li,null,r.createElement(n.code,null,"wordList[i].length == beginWord.length")),"\n",r.createElement(n.li,null,r.createElement(n.code,null,"beginWord, endWord, and wordList[i] consist of lowercase English letters.")),"\n",r.createElement(n.li,null,r.createElement(n.code,null,"beginWord != endWord")),"\n",r.createElement(n.li,null,r.createElement(n.code,null,"All the words in wordList are unique.")),"\n"),"\n",r.createElement(n.h2,{id:"approach---graph-bfs-시간초과",style:{position:"relative"}},r.createElement(n.a,{href:"#approach---graph-bfs-%EC%8B%9C%EA%B0%84%EC%B4%88%EA%B3%BC","aria-label":"approach   graph bfs 시간초과 permalink",className:"header-links before"},r.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Approach - Graph: BFS (시간초과…)"),"\n",r.createElement(n.p,null,"처음 풀어보는 LeetCode Hard 난이도 문제였다. 풀면서 ‘뭐야 생각보다 쉽잖아’ 생각했지만 난이도를 높인 주범은 그래프 탐색과는 무관한 문자열 처리에 있었다… 문자열의 길이가 ",r.createElement(n.code,null,"10"),"이고 ",r.createElement(n.code,null,"wordList"),"길이가 ",r.createElement(n.code,null,"5000"),"이므로 배열 안의 문자열들을 naive하게 비교해서 그래프를 만들면 ",r.createElement(n.code,null,"O(N^2 M)")," = 250,000,000이 나오면서 터져버린다.."),"\n",r.createElement(n.p,null,"그 뒤 부분은 단순한 BFS여서 딱히 설명할 것이 없네."),"\n",r.createElement(n.h4,{id:"complexity",style:{position:"relative"}},r.createElement(n.a,{href:"#complexity","aria-label":"complexity permalink",className:"header-links before"},r.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Complexity"),"\n",r.createElement(n.ul,null,"\n",r.createElement(n.li,null,"time complexity: ",r.createElement(n.code,null,"O(N^2 M)")," = 250,000,000"),"\n",r.createElement(n.li,null,"space complexity: ",r.createElement(n.code,null,"O(N^2)")),"\n"),"\n",r.createElement(n.h4,{id:"code",style:{position:"relative"}},r.createElement(n.a,{href:"#code","aria-label":"code permalink",className:"header-links before"},r.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Code"),"\n",r.createElement(n.pre,null,r.createElement(n.code,{className:"language-python"},"from collections import deque\n\nclass Solution:\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\n        graph = defaultdict(list)\n        wordList.append(beginWord)\n        visited = set()\n        \n        # 5000 * 5000 * 10 = 250,000,000.\n        for i in range(len(wordList) - 1):\n            for j in range(i + 1, len(wordList)):\n                count = 0\n                # 10 \n                for k in range(len(wordList[0])):\n                    if wordList[i][k] != wordList[j][k]:\n                        count += 1\n                if count == 1:\n                    graph[wordList[i]].append(wordList[j])\n                    graph[wordList[j]].append(wordList[i])\n\n        q = deque([(beginWord, 1)])\n        visited.add(beginWord)\n\n        while q:\n            word, d = q.popleft()\n            if word == endWord:\n                return d\n\n            for adj in graph[word]:\n                if adj not in visited:\n                    q.append((adj, d + 1))\n                    visited.add(adj)\n        \n        return 0\n")),"\n",r.createElement(n.h2,{id:"approach---graph-bfs-on-m2-솔루션",style:{position:"relative"}},r.createElement(n.a,{href:"#approach---graph-bfs-on-m2-%EC%86%94%EB%A3%A8%EC%85%98","aria-label":"approach   graph bfs on m2 솔루션 permalink",className:"header-links before"},r.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Approach - Graph: BFS O(N M^2) 솔루션"),"\n",r.createElement(n.p,null,r.createElement(n.a,{href:"https://www.youtube.com/watch?v=h9iTnkgv05E",target:"_self",rel:"nofollow"},"NeetCode의 솔루션"),"을 참고했다."),"\n",r.createElement(n.p,null,"그래프를 단어들로 만든게 아니라 각 단어들의 pattern으로 만들었다..! 아이디어는 이랬다.\nhot과 hog는 뒷 부분 한 자리만 다르다. 따라서 이들을 ",r.createElement(n.code,null,"ho*"),"이라는 asterisk로 처리한 dictionary에서 한 번에 확인한다면 한 자리씩만 다른 (완전히 같은 녀석들도 나중에 순회할 때 비교해서 제외하면 됨.) 원소들만 해당 key에 들어가있지 않을까?\n그래서 ",r.createElement(n.code,null,"wordList"),"를 순회하며 그 안에서는 단어의 첫번째 ~ 마지막까지 하나씩 asterisk로 변환한 뒤 원래 단어를 asterisk 키에 추가해준다."),"\n",r.createElement(n.p,null,"그리고 나중에 BFS에서 이웃 노드를 순회할 때도 역시 word의 첫번째 ~ 마지막까지 asterisk로 바꾼 패턴화된 문자열을 dict에 대입해 나온 이웃들을 순회하는 것이다.\n실전에서 이런 아이디어 어떻게 내지.."),"\n",r.createElement(n.h4,{id:"complexity-1",style:{position:"relative"}},r.createElement(n.a,{href:"#complexity-1","aria-label":"complexity 1 permalink",className:"header-links before"},r.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Complexity"),"\n",r.createElement(n.ul,null,"\n",r.createElement(n.li,null,"time complexity: ",r.createElement(n.code,null,"O(N M^2)")," = 500,000"),"\n",r.createElement(n.li,null,"space complexity:"),"\n"),"\n",r.createElement(n.h4,{id:"code-1",style:{position:"relative"}},r.createElement(n.a,{href:"#code-1","aria-label":"code 1 permalink",className:"header-links before"},r.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Code"),"\n",r.createElement(n.pre,null,r.createElement(n.code,{className:"language-python"},'from collections import deque\n\nclass Solution:\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\n        graph = collections.defaultdict(list)\n        visited = set(beginWord)\n        wordList.append(beginWord)\n\n        # O(N M^2)\n        for w in wordList:\n            for i in range(len(w)):\n                pattern = w[:i] + "*" + w[i + 1:]\n                graph[pattern].append(w)\n        \n        q = deque([(beginWord, 1)])\n        \n        # O(N M^2)\n        while q:\n            word, d = q.popleft()\n            if word == endWord:\n                return d\n            \n            for i in range(len(word)):\n                pattern = word[:i] + "*" + word[i + 1:]\n                for adj in graph[pattern]:\n                    if adj not in visited:\n                        q.append((adj, d + 1))\n                        visited.add(adj)\n\n        return 0\n')))}var i=function(e={}){const{wrapper:n}=Object.assign({},(0,l.ah)(),e.components);return n?r.createElement(n,e,r.createElement(a,e)):a(e)},c=t(5670),d=t(1326),o=t(4517),s=t(698),h=t(8627),m=t(662),p=t(1873);const u=({data:e,children:n,serverData:t})=>{const{prevPost:l,nextPost:a}=e,i={...e.mdx.frontmatter,timeToRead:e.mdx.fields.timeToRead};return r.createElement(s.Z,{data:e},r.createElement(c.Z,null,r.createElement(o.Z,i),r.createElement(d.Z,null,n),r.createElement(m.Z,{prev:l,next:a}),r.createElement(h.Z)))};function E(e){return r.createElement(u,e,r.createElement(i,e))}}}]);
//# sourceMappingURL=component---src-templates-article-page-jsx-content-file-path-home-runner-work-leobang-17-github-io-leobang-17-github-io-documents-algorithm-127-word-ladder-md-09c5ffc2eab11270ca6c.js.map