"use strict";(self.webpackChunkgatsby_theme_simplex=self.webpackChunkgatsby_theme_simplex||[]).push([[6082],{6024:function(e,n,l){l.r(n),l.d(n,{Head:function(){return h.py},default:function(){return E}});var t=l(1151),a=l(7294);function r(e){const n=Object.assign({p:"p",code:"code",h2:"h2",a:"a",div:"div",strong:"strong",blockquote:"blockquote",h4:"h4",h5:"h5",em:"em",ol:"ol",li:"li",pre:"pre",ul:"ul"},(0,t.ah)(),e.components);return a.createElement(a.Fragment,null,a.createElement(n.p,null,"macOS 환경에서 종종 docker desktop 애플리케이션을 실행하지 않은 상태에서 ",a.createElement(n.code,null,"docker")," command를 날리면 “docker daemon에 연결할 수 없다”는 에러를 받곤한다."),"\n",a.createElement(n.p,null,"docker를 설치했는데, 그냥은 사용할 수 없고 docker desktop이라는 애플리케이션을 실행해야 사용할 수 있다니 좀 이상하다. 왜일까?"),"\n",a.createElement(n.h2,{id:"docker는-linux-커널에-의존한다",style:{position:"relative"}},a.createElement(n.a,{href:"#docker%EB%8A%94-linux-%EC%BB%A4%EB%84%90%EC%97%90-%EC%9D%98%EC%A1%B4%ED%95%9C%EB%8B%A4","aria-label":"docker는 linux 커널에 의존한다 permalink",className:"header-links before"},a.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Docker는 Linux 커널에 의존한다"),"\n",a.createElement(n.p,null,"Docker는 기본적으로 Linux 용이다. 이 말은, ",a.createElement(n.strong,null,"Docker의 주요 기술이 linux kernel의 기능을 기반"),"으로 한다는 의미이다. 구체적으로 설명하자면, Docker는 container를 생성하고 관리하기 위해 linux kernel에서 제공하는 여러 기능을 활용한다. 주요한 두 가지는 linux의 namespace와 cgroup이다."),"\n",a.createElement(n.blockquote,null,"\n",a.createElement(n.p,null,"참고로, docker는 64bit 운영체제 위에서만 동작한다. 32bit 컴퓨터에서는 docker를 사용할 수 없다."),"\n"),"\n",a.createElement(n.p,null,"Docker container는 Host 시스템 입장에서 보자면 프로세스이다. docker engine은 linux kernel의 namespace와 cgroup을 활용해서 각 프로세스 (container)를 격리된 환경에서 실행한다."),"\n",a.createElement(n.h4,{id:"namespace",style:{position:"relative"}},a.createElement(n.a,{href:"#namespace","aria-label":"namespace permalink",className:"header-links before"},a.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"namespace"),"\n",a.createElement(n.p,null,"namespace는 하나의 linux kernel에서 여러 ",a.createElement(n.strong,null,"독립적인 실행 환경"),"을 만들 수 있도록 지원하는 기술이다. 주로 프로세스, 네트워크, 파일 시스템, 사용자 등을 ",a.createElement(n.strong,null,"격리"),"하는데 사용된다. namespace를 통해서 Docker는 container간의 격리된 환경을 구성할 수 있는 것이다."),"\n",a.createElement(n.p,null,"linux의 namespace에는 여러 종류가 있으며, 각각의 namespace는 시스템의 특정 리소스를 격리하는 역할을 한다. namespace들을 docker container 기술과 연관지어 이해해보자."),"\n",a.createElement(n.h5,{id:"pid-namespace",style:{position:"relative"}},a.createElement(n.a,{href:"#pid-namespace","aria-label":"pid namespace permalink",className:"header-links before"},a.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),a.createElement(n.strong,null,"PID namespace")),"\n",a.createElement(n.p,null,"PID를 격리하는 namespace. 각 PID namespace는 자체적인 Process ID를 가진다. 물론 namespace 내에서의 PID는 고유해야한다. 부모 namespace는 자식 namespace의 프로세스를 볼 수 있지만, 그 역은 불가능하다."),"\n",a.createElement(n.p,null,"Docker의 경우 각 container는 독립적인 PID namespace를 가지며, ",a.createElement(n.strong,null,"자체적인 process tree를 형성"),"한다. 이 process tree는 host 머신의 tree와는 별도로 관리되기 때문에 host혹은 다른 container의 프로세스와 충돌하지 않는다."),"\n",a.createElement(n.blockquote,null,"\n",a.createElement(n.p,null,"docker container에서 init process는 PID 1을 부여받는다. PID namespace가 동작하기 때문에 가능한 일이다."),"\n"),"\n",a.createElement(n.h5,{id:"net-namespace",style:{position:"relative"}},a.createElement(n.a,{href:"#net-namespace","aria-label":"net namespace permalink",className:"header-links before"},a.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"NET namespace"),"\n",a.createElement(n.p,null,"네트워크 인터페이스를 격리한다. 각 namespace는 커널의 네트워크 스택을 가상화하여, 자체적인 네트워크 장치, IP 주소, 라우팅 테이블 등을 가진다."),"\n",a.createElement(n.p,null,"docker의 각 container는 자체적인 NET namespace를 가지기 때문에, 독립적인 네트워크 장치, IP 주소, 라우팅 테이블 등을 사용한다. 이를 통해 container 간 네트워크 트래픽이 격리되며, 각 container는 독립적인 network 설정을 가질 수 있다."),"\n",a.createElement(n.p,null,"격리된 network 환경에서는 NAT 기술과 포트포워딩을 통해서 외부 네트워크와 통신할 수 있다."),"\n",a.createElement(n.h5,{id:"mnt-namespace",style:{position:"relative"}},a.createElement(n.a,{href:"#mnt-namespace","aria-label":"mnt namespace permalink",className:"header-links before"},a.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"MNT namespace"),"\n",a.createElement(n.p,null,"파일 시스템 파운트를 격리한다. 각 MNT namespace는 자체적인 ",a.createElement(n.em,null,"마운트 포인트 목록"),"을 가진다."),"\n",a.createElement(n.p,null,"이를 통해 container마다 각기 다른 파일 시스템 뷰를 제공한다. 또한 새로운 마운트나 언마운트 작업이 namespace 내부에 한정되므로, host 시스템이나 다른 container에게 영향을 주지 않는다."),"\n",a.createElement(n.h5,{id:"uts-namespace-unix-time-sharing",style:{position:"relative"}},a.createElement(n.a,{href:"#uts-namespace-unix-time-sharing","aria-label":"uts namespace unix time sharing permalink",className:"header-links before"},a.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"UTS namespace (UNIX time-sharing)"),"\n",a.createElement(n.p,null,"host 도메인과 다른 process의 domain name을 격리한다. 프로세스가 새 UTS namespace를 생성하면 호출자의 UTS namespace 정보 (hostname과 domain)가 새로운 UTS namespace에 복제된다."),"\n",a.createElement(n.p,null,"docker container는 이를 통해 독립적인 host name과 domain name을 설정할 수 있다. container 내부에서 host name을 변경해도 Host PC에는 문제가 없다."),"\n",a.createElement(n.blockquote,null,"\n",a.createElement(n.p,null,a.createElement(n.code,null,"hostname")," 커맨드를 이용해서 host 이름을 바꾸어도!"),"\n"),"\n",a.createElement(n.h5,{id:"ipc-namespace",style:{position:"relative"}},a.createElement(n.a,{href:"#ipc-namespace","aria-label":"ipc namespace permalink",className:"header-links before"},a.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"IPC namespace"),"\n",a.createElement(n.p,null,"각 프로세스들의 SysV 스타일의 IPC 객체 및 POSIX 메시지 큐를 격리한다."),"\n",a.createElement(n.p,null,"각 IPC namespace는 독자적인 IPC 리소스를 가지므로, container 간에도 IPC 리소스가 충돌하지 않는다."),"\n",a.createElement(n.h5,{id:"user-namespace",style:{position:"relative"}},a.createElement(n.a,{href:"#user-namespace","aria-label":"user namespace permalink",className:"header-links before"},a.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"USER namespace"),"\n",a.createElement(n.p,null,"사용자 및 그룹의 ID를 격리한다. 각 user namespace에서는 독립적인 user 및 group id 매핑을 가진다. 이를 통해서 namespace 내에서 root 권한을 부여하면서도 Host 시스템에 영향을 주지 않도록 할 수 있다."),"\n",a.createElement(n.h4,{id:"cgroup-control-group",style:{position:"relative"}},a.createElement(n.a,{href:"#cgroup-control-group","aria-label":"cgroup control group permalink",className:"header-links before"},a.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"cgroup (control group)"),"\n",a.createElement(n.p,null,"linux의 cgroup은 ",a.createElement(n.strong,null,"프로세스의 리소스를 제어하고 제한"),"하는 메커니즘이다. cgroup을 통해서 CPU, 메모리, Disk I/O, 네트워크 대역폭 등의 리소스를 process 그룹에게 할당하고 관리할 수 있다. docker container에서 cgroup은 ",a.createElement(n.strong,null,"container의 리소스를 효율적으로 관리하고 제한"),"하는데 이용된다."),"\n",a.createElement(n.ol,null,"\n",a.createElement(n.li,null,"Resource Limiting"),"\n"),"\n",a.createElement(n.p,null,"container의 CPU를 제한해보자."),"\n",a.createElement(n.pre,null,a.createElement(n.code,null,'docker run --cpus="1.5" <image>\n')),"\n",a.createElement(n.p,null,"이 커맨드를 통해서 container가 최대 1.5개의 CPU를 사용할 수 있도록 제한한다. 이 때 내부적으로 linux kernel의 cgroup을 이용해서 container process의 CPU 할당량을 제한하는 것이다."),"\n",a.createElement(n.p,null,"이번엔 container의 메모리를 제한해보자."),"\n",a.createElement(n.pre,null,a.createElement(n.code,null,'docker run --memory="512m" <image>\n')),"\n",a.createElement(n.p,null,"역시 docker engine은 내부적으로 linux kernel의 cgroup을 이용해 해당 container process의 memory 할당량을 제한한다."),"\n",a.createElement(n.ol,{start:"2"},"\n",a.createElement(n.li,null,"Resource Isolation"),"\n"),"\n",a.createElement(n.p,null,"Docker는 cgroup을 이용해서 ",a.createElement(n.strong,null,"각 container의 리소스를 독립적으로 관리"),"한다."),"\n",a.createElement(n.ol,{start:"3"},"\n",a.createElement(n.li,null,"Resource Accounting"),"\n"),"\n",a.createElement(n.p,null,"cgroup을 통해서 ",a.createElement(n.strong,null,"각 프로세스 그룹의 리소스 사용량을 추적"),"할 수 있다. 이는 성능 모니터링과 애플리케이션 상태 관리에 매우 유용하다."),"\n",a.createElement(n.ol,{start:"4"},"\n",a.createElement(n.li,null,"Resource Control"),"\n"),"\n",a.createElement(n.p,null,"특정 트리거 (i.e. 메모리 사용량 초과)가 발생했을 때 특정 조치를 취할 수 있다. 예를들어, container에게 할당한 메모리 한도를 초과하면 cotnainer를 종료하거나 경고를 발생시킬 수 있다."),"\n",a.createElement(n.h2,{id:"docker-desktop",style:{position:"relative"}},a.createElement(n.a,{href:"#docker-desktop","aria-label":"docker desktop permalink",className:"header-links before"},a.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Docker Desktop"),"\n",a.createElement(n.p,null,"이처럼 Docker Engine은 linux kernel의 핵심 기능을 활용해서 container를 관리하기 때문에, 실행하기 위해서는 linux OS가 필요하다. 그렇지만 우리는 mac이나 windows 환경에서도 docker를 잘 활용하고 있다. 어떻게 가능한 걸까?"),"\n",a.createElement(n.p,null,"window와 macOS에서는 각각 ‘window용/macOS용 Docker Desktop’이 패키지 형태로 제공된다. ",a.createElement(n.strong,null,"Docker Desktop"),"은 ",a.createElement(n.strong,null,"linux가 아닌 운영체제 환경에서 Docker를 사용할 수 있도록 지원"),"하는 통합 애플리케이션이다."),"\n",a.createElement(n.blockquote,null,"\n",a.createElement(n.p,null,a.createElement(n.strong,null,"사실 window의 경우엔 docker desktop 없이도 docker engine을 실행할 수 있다.")),"\n",a.createElement(n.p,null,"Docker는 Windows Server 2016 부터는 Windows container를 지원하기 때문이다. linux container와 유사하지만, windows kernel 기능을 사용해서 동작한다."),"\n"),"\n",a.createElement(n.p,null,"Docker Desktop 애플리케이션은 다음과 같이 구성된다."),"\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,"가상머신 및 경량 Linux 운영체제","\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,"windows에서는 Hyper-V 또는 WSL 기반의 가상머신"),"\n",a.createElement(n.li,null,"macOS에서는 HyperKit 또는 Apple의 Hypervisor Framework을 사용해서 경량 가상머신을 실행한다."),"\n"),"\n"),"\n",a.createElement(n.li,null,"Docker Engine","\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,"docker desktop이 지원하는 VM으로 linux 환경이 준비되었으니, 이제 Docker Engine을 실행할 수 있다!"),"\n"),"\n"),"\n",a.createElement(n.li,null,"Docker CLI","\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,a.createElement(n.code,null,"docker")," 커맨드를 사용해 Docker Engine에게 REST API 요청을 보낼 수 있다. Docker Engine은 이를 다시 docker daemon에게 전달하여 실질적으로 container를 조작하게 된다."),"\n"),"\n"),"\n",a.createElement(n.li,null,"Docker Dashboard","\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,"Docker Desktop에 포함된 GUI 툴"),"\n"),"\n"),"\n",a.createElement(n.li,null,"Docker Compose","\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,"Docker Desktop에 딸려왔기 때문에 docker compose 설치 없이도 커맨드를 실행할 수 있다."),"\n"),"\n"),"\n",a.createElement(n.li,null,"Kubernetes"),"\n"),"\n",a.createElement(n.p,null,"이처럼 Docker Desktop은 Linux OS 환경을 위한 VM을 탑재한만큼, 꽤 무거운 프로세스이다. docker 작업만 하면 노트북이 느려지는 이유가 있었다."),"\n",a.createElement(n.h2,{id:"docker-toolbox",style:{position:"relative"}},a.createElement(n.a,{href:"#docker-toolbox","aria-label":"docker toolbox permalink",className:"header-links before"},a.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Docker Toolbox"),"\n",a.createElement(n.p,null,"Docker Desktop이 나오기 전에는 Linux가 아닌 운영체제에서 Docker를 실행하기 위해 도커 툴박스를 사용했다. 현재는 deprecated 되었고, docker desktop을 권장한다."),"\n",a.createElement(n.p,null,"둘 사이의 가장 큰 차이점은 vitrualization을 수행하는 소프트웨어에 있다. docker desktop은 window와 macOS 두 환경에 각각 Hyper-V, HyperKit을 사용하지만 툴박스의 경우 두 운영체제에 차이점을 두지 않았고 모두 ",a.createElement(n.em,null,"VirtualBox를 사용해 가상화"),"를 진행한다."),"\n",a.createElement(n.h2,{id:"references",style:{position:"relative"}},a.createElement(n.a,{href:"#references","aria-label":"references permalink",className:"header-links before"},a.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"References"),"\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,a.createElement(n.a,{href:"https://en.wikipedia.org/wiki/Linux_namespaces#:~:text=UTS%20(UNIX%20Time%2DSharing),in%20the%20caller's%20UTS%20namespace.%22",target:"_self",rel:"nofollow"},"wikipedia  - Linux namespace")),"\n",a.createElement(n.li,null,a.createElement(n.a,{href:"https://en.wikipedia.org/wiki/Cgroups",target:"_self",rel:"nofollow"},"wikipedia - Linux cgroup")),"\n",a.createElement(n.li,null,a.createElement(n.a,{href:"https://docs.docker.com/desktop/",target:"_self",rel:"nofollow"},"Docker Docs - docker desktop")),"\n"))}var c=function(e={}){const{wrapper:n}=Object.assign({},(0,t.ah)(),e.components);return n?a.createElement(n,e,a.createElement(r,e)):r(e)},o=l(5670),i=l(1326),s=l(4517),m=l(698),u=l(8627),p=l(662),h=l(1873);const d=({data:e,children:n,serverData:l})=>{const{prevPost:t,nextPost:r}=e,c={...e.mdx.frontmatter,timeToRead:e.mdx.fields.timeToRead};return a.createElement(m.Z,{data:e},a.createElement(o.Z,null,a.createElement(s.Z,c),a.createElement(i.Z,null,n),a.createElement(p.Z,{prev:t,next:r}),a.createElement(u.Z)))};function E(e){return a.createElement(d,e,a.createElement(c,e))}}}]);
//# sourceMappingURL=component---src-templates-article-page-jsx-content-file-path-users-leobang-blog-starter-documents-docker-docker는-linux에-의존한다-md-8d0ebf245c680906dad1.js.map