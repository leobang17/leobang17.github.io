"use strict";(self.webpackChunkgatsby_theme_simplex=self.webpackChunkgatsby_theme_simplex||[]).push([[5041],{2237:function(e,t,a){a.r(t),a.d(t,{Head:function(){return p.py},default:function(){return v}});var r=a(1151),n=a(7294);function l(e){const t=Object.assign({h2:"h2",a:"a",div:"div",p:"p",code:"code",em:"em",strong:"strong",h4:"h4",pre:"pre"},(0,r.ah)(),e.components);return n.createElement(n.Fragment,null,n.createElement(t.h2,{id:"javascript의-배열은-object다",style:{position:"relative"}},n.createElement(t.a,{href:"#javascript%EC%9D%98-%EB%B0%B0%EC%97%B4%EC%9D%80-object%EB%8B%A4","aria-label":"javascript의 배열은 object다 permalink",className:"header-links before"},n.createElement(t.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Javascript의 배열은 Object다"),"\n",n.createElement(t.p,null,"Javascript에는 엄밀한 수준의 ‘static array’를 지원하지 않는다. ",n.createElement(t.code,null,"Array"),"라는 배열을 흉내낸 type을 지원하지만 사실 이마저도 내부적으로 보면 ",n.createElement(t.em,null,"배열이 아닌 객체에 가깝다"),". ArrayList도 아니고 LinkedList도 아닌 것이, 그냥 ",n.createElement(t.strong,null,"배열의 형태를 흉내낸 객체"),"이다."),"\n",n.createElement(t.h4,{id:"javascript-array는-index를-문자열로-접근한다",style:{position:"relative"}},n.createElement(t.a,{href:"#javascript-array%EB%8A%94-index%EB%A5%BC-%EB%AC%B8%EC%9E%90%EC%97%B4%EB%A1%9C-%EC%A0%91%EA%B7%BC%ED%95%9C%EB%8B%A4","aria-label":"javascript array는 index를 문자열로 접근한다 permalink",className:"header-links before"},n.createElement(t.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Javascript Array는 index를 문자열로 접근한다?"),"\n",n.createElement(t.p,null,"Javascript의 배열은 Object와 같이, ",n.createElement(t.strong,null,"key-value 쌍으로 데이터를 저장"),"한다.이 때의 key 값은 ",n.createElement(t.em,null,"주로 ",n.createElement(t.code,null,"number")," 타입의 index를 사용"),"한다."),"\n",n.createElement(t.p,null,"하지만 Javascript의 Array는 객체인 것을 잊지말자. Object의 key는 ",n.createElement(t.code,null,"string")," 혹은 ",n.createElement(t.code,null,"symbol")," type을 허용한다. 만약 Object type의 key로 ",n.createElement(t.code,null,"number")," type을 제공할 경우 자동으로 ",n.createElement(t.code,null,"string")," type으로 변환된다. ",n.createElement(t.code,null,"1")," 이라는 index는 사실 내부적으로 ",n.createElement(t.code,null,'"1"'),"로 변환되어 key로 들어가게 된다. 따라서, Array의 key 값으로 ",n.createElement(t.code,null,"number")," 형식의 ",n.createElement(t.code,null,"string"),"을 던져주어도 ‘당연히’ 동작한다. Javascript는 참 요상하다."),"\n",n.createElement(t.pre,null,n.createElement(t.code,{className:"language-javascript"},'const name = ["leo", "bang", "seok", "jin"];\nconsole.log(name["2"]); // seok \n')),"\n",n.createElement(t.p,null,"다음으로는 Array의 property를 직접 확인해보자."),"\n",n.createElement(t.pre,null,n.createElement(t.code,{className:"language-javascript"},"Object.getOwnPropertyDescriptors([1, 2, 3]));\n/*\n{\n  '0': { value: 1, writable: true, enumerable: true, configurable: true },\n  '1': { value: 2, writable: true, enumerable: true, configurable: true },\n  '2': { value: 3, writable: true, enumerable: true, configurable: true },\n  length: { value: 3, writable: true, enumerable: false, configurable: false }\n}\n*/\n")),"\n",n.createElement(t.p,null,"key는 역시 number 형식의  ",n.createElement(t.code,null,"string")," type으로 저장되어있다. 또한, Javascript의 배열은 index를 property key로 갖는 객체에 불과하다는 것을 눈으로 확인할 수 있다."),"\n",n.createElement(t.h4,{id:"그럼-javascript의-배열은-연속된-공간에-저장되지-않는가",style:{position:"relative"}},n.createElement(t.a,{href:"#%EA%B7%B8%EB%9F%BC-javascript%EC%9D%98-%EB%B0%B0%EC%97%B4%EC%9D%80-%EC%97%B0%EC%86%8D%EB%90%9C-%EA%B3%B5%EA%B0%84%EC%97%90-%EC%A0%80%EC%9E%A5%EB%90%98%EC%A7%80-%EC%95%8A%EB%8A%94%EA%B0%80","aria-label":"그럼 javascript의 배열은 연속된 공간에 저장되지 않는가 permalink",className:"header-links before"},n.createElement(t.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"그럼 Javascript의 배열은 연속된 공간에 저장되지 않는가?"),"\n",n.createElement(t.p,null,"Javascript의 배열은 Object이다. 그렇기에 사실 내부적으로 ",n.createElement(t.code,null,"Array")," 내부의 ",n.createElement(t.em,null,"data type이 동일할 것을 강요 받지 않는다"),". 그런데 data type이 동일하지 않다면, 어떠한 크기를 갖는 자료가 연속적으로 위치할지 예측할 수 없기 때문에 연속적인 메모리 영역을 할당하기 어렵다···"),"\n",n.createElement(t.p,null,"그렇기에 Javascript는 일반적으로는 ",n.createElement(t.em,null,"sparse array"),"라고 할 수 있다. Array 내부에 다양한 type의 data가 혼재해있는 경우 ",n.createElement(t.code,null,"Array"),"는 일반적인 ‘array’ 보다는 ",n.createElement("u",null,"Hash Table과 유사한 방식"),"으로 관리된다. 그렇기에 연속적인 공간을 할당받지 않는다. 유연성을 얻고 속도를 희생한 셈이다."),"\n",n.createElement(t.p,null,"하지만 ",n.createElement(t.code,null,"Array"),"는 이름부터 ‘배열’임을 선포한 자료형인만큼, Javascript 엔진은 이에 대한 최적화를 내부에서 수행한다. Javascript 엔진은 ",n.createElement(t.code,null,"Array"),"에 저장된 자료형이 모두 동일하고, 자료형의 메모리 공간이 동적으로 확장/축소되지 않는 primitive type일 경우엔 내부적으로 C++과 유사하게 관리하며 data들을 연속된 메모리에 저장한다. 예를들어, 모두 ",n.createElement(t.code,null,"number")," type으로 저장된 ",n.createElement(t.code,null,"Array"),"에 대해서는 일반적인 ‘array’에게 기대할 수 있는 cache hit과 같은 성능 이점을 기대할 수 있는 것이다."))}var c=function(e={}){const{wrapper:t}=Object.assign({},(0,r.ah)(),e.components);return t?n.createElement(t,e,n.createElement(l,e)):l(e)},i=a(5670),s=a(1326),m=a(4517),u=a(698),E=a(8627),o=a(662),p=a(1873);const d=({data:e,children:t,serverData:a})=>{const{prevPost:r,nextPost:l}=e,c={...e.mdx.frontmatter,timeToRead:e.mdx.fields.timeToRead};return n.createElement(u.Z,{data:e},n.createElement(i.Z,null,n.createElement(m.Z,c),n.createElement(s.Z,null,t),n.createElement(o.Z,{prev:r,next:l}),n.createElement(E.Z)))};function v(e){return n.createElement(d,e,n.createElement(c,e))}}}]);
//# sourceMappingURL=component---src-templates-article-page-jsx-content-file-path-home-runner-work-leobang-17-github-io-leobang-17-github-io-documents-node-js-javascript-array-md-bcfdc5267f9c7d77d7ed.js.map