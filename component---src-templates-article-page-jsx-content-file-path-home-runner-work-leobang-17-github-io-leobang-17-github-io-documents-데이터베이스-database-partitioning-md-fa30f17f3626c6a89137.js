"use strict";(self.webpackChunkgatsby_theme_simplex=self.webpackChunkgatsby_theme_simplex||[]).push([[2580],{8223:function(e,t,n){n.r(t),n.d(t,{Head:function(){return E.py},default:function(){return d}});var l=n(1151),a=n(7294);function r(e){const t=Object.assign({h2:"h2",a:"a",div:"div",p:"p",h5:"h5",blockquote:"blockquote",pre:"pre",code:"code",ul:"ul",li:"li"},(0,l.ah)(),e.components);return a.createElement(a.Fragment,null,a.createElement(t.h2,{id:"partitioning이란",style:{position:"relative"}},a.createElement(t.a,{href:"#partitioning%EC%9D%B4%EB%9E%80","aria-label":"partitioning이란 permalink",className:"header-links before"},a.createElement(t.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Partitioning이란"),"\n",a.createElement(t.p,null,"database table을 더 작은 크기의 테이블로 나누는 것을 말한다."),"\n",a.createElement(t.h5,{id:"vertical-partitioning이란",style:{position:"relative"}},a.createElement(t.a,{href:"#vertical-partitioning%EC%9D%B4%EB%9E%80","aria-label":"vertical partitioning이란 permalink",className:"header-links before"},a.createElement(t.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Vertical Partitioning이란?"),"\n",a.createElement(t.p,null,a.createElement("u",null,"Column을 기준으로 table을 나누는")," 방식이다. 따라서 테이블의 스키마가 바뀌며, 새로운 테이블이 한 개 이상 생기게 된다."),"\n",a.createElement(t.blockquote,null,"\n",a.createElement(t.p,null,"정규화 역시 vertical partitioning의 한 방식이다."),"\n"),"\n",a.createElement(t.p,null,"![image-20231026120943090](/Users/leobang/Library/Application Support/typora-user-images/image-20231026120943090.png)"),"\n",a.createElement(t.p,null,"Select문을 실행하면, 아무리 select에 원하는 column만을 지정해두어도 일단 query가 동작하는 방식은 해당 테이블의 row를 모두 가져온 후에 원하는 column만 반환하게 된다. 예를들어:"),"\n",a.createElement(t.pre,null,a.createElement(t.code,{className:"language-sql"},"SELECT id, title, ... ,commend_cnt FROM article WHERE ...;\n")),"\n",a.createElement(t.ul,null,"\n",a.createElement(t.li,null,"이 SQL문을 실행하더라도 실제 schema에 content라는 attribute가 있다면 그 것까지 모두 HDD 혹은 SSD에서 읽어들인다는 뜻이다."),"\n"),"\n",a.createElement(t.p,null,"그런데 만약 읽기가 자주 일어나는 query에 불필요한 attribute의 크기가 굉장히 큰 경우라면? 불필요하게 I/O에 영향을 주게 된다. (물론 index를 잘 걸어두었거나 했다면 괜찮지만 full-scan을 했을 때는 체감이 될 수도 있다.)"),"\n",a.createElement(t.p,null,"이 때 ARTICLE 테이블에서 content 속성을 빼고, 새로운 ARTICLE_CONTENT 테이블에 해당 속성을 추가하여 따로 색인할 수 있도록 분리하는 것을 vertical partitioning 이라고 한다."),"\n",a.createElement(t.h5,{id:"horizontal-partitioning이란",style:{position:"relative"}},a.createElement(t.a,{href:"#horizontal-partitioning%EC%9D%B4%EB%9E%80","aria-label":"horizontal partitioning이란 permalink",className:"header-links before"},a.createElement(t.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Horizontal Partitioning이란?"),"\n",a.createElement(t.p,null,"Row를 기준으로 table을 나누는 방식이다. 따라서 테이블의 스키마는 변함이 없다."),"\n",a.createElement(t.p,null,"만약 인덱스를 걸어두었을 경우, 테이블의 크기가 커질수록 인덱스의 크기도 커지게 된다. 즉, 테이블에 읽기/쓰기가 있을 때마다 index에서 처리되는 시간도 조금씩 늘어난다는 뜻이다."),"\n",a.createElement(t.p,null,"이렇게 하나의 테이블이 너무너무 row가 많아졌을 때 수평으로 뎅강해서 테이블을 나누는 것을 horizontal partitioning이라고 한다."),"\n",a.createElement(t.h5,{id:"horizontal-partitioning을-구현하는-방법-hash-based",style:{position:"relative"}},a.createElement(t.a,{href:"#horizontal-partitioning%EC%9D%84-%EA%B5%AC%ED%98%84%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95-hash-based","aria-label":"horizontal partitioning을 구현하는 방법 hash based permalink",className:"header-links before"},a.createElement(t.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Horizontal Partitioning을 구현하는 방법: Hash-Based"),"\n",a.createElement(t.p,null,"Hash function을 하나 마련한다. 특정 key를 넣어주면 해당 key의 row가 저장되어 있는/저장될 테이블을 가리키는 값을 반환해준다."),"\n",a.createElement(t.ul,null,"\n",a.createElement(t.li,null,"이 때 Hash function에 입력되는 key를 ",a.createElement("u",null,"Partition Key"),"라고 부른다."),"\n"),"\n",a.createElement(t.p,null,"Partitoin Key를 올바르게 설계하는 것은 매우 중요하다. 다음의 예시를 생각해보자:"),"\n",a.createElement(t.ul,null,"\n",a.createElement(t.li,null,"\n",a.createElement(t.p,null,"partition key를 user_id로 지정했지만, 어떠한 query의 경우 member_name을 기준으로 SELECT를 하고 싶다면?"),"\n"),"\n",a.createElement(t.li,null,"\n",a.createElement(t.p,null,"이 때는 모든 수평분할된 테이블을 조회해주어야 한다. member_name을 기준으로 나눈게 아니기 때문이다."),"\n"),"\n",a.createElement(t.li,null,"\n",a.createElement(t.p,null,"따라서, ",a.createElement("u",null,"가장 많이 사용될 패턴에 따라 partition key를 정해주는 것"),"이 굉장히 중요하다."),"\n"),"\n"),"\n",a.createElement(t.p,null,"또한, 데이터가 균등하게 분배될 수 있도록 hash function을 잘 정의하는 것도 중요하다."),"\n",a.createElement(t.p,null,"Horizontal Partitioning의 단점은 ",a.createElement("u",null,"한번 partiton이 나눠져서 사용되고 있다면 이후에 partiton을 추가하기 까다롭다"),"는 점이다."),"\n",a.createElement(t.ul,null,"\n",a.createElement(t.li,null,"파티션을 ",1,"로 나누어 파티셔닝을 운용하고 있다가 나중에 파티션을 ",3,"으로 늘리고 싶다고 생각해보자."),"\n",a.createElement(t.li,null,"이는 가능하긴 하지만 ",1,"의 데이터를 다시 ",3,"으로 나눌 hash funciton을 재정의하고 해당 hash에 따라 데이터를 모두 옮겨주어야 하므로 부하가 큰 작업이 될 수 있다. 초반에 설계를 잘 하자."),"\n"),"\n",a.createElement(t.h2,{id:"sharding이란",style:{position:"relative"}},a.createElement(t.a,{href:"#sharding%EC%9D%B4%EB%9E%80","aria-label":"sharding이란 permalink",className:"header-links before"},a.createElement(t.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Sharding이란?"),"\n",a.createElement(t.p,null,"Horizontal Partitoning처럼 동작한다. 개념 자체는 동일하다! 하지만 Horizontal Partitioning과 다른 점은 ",a.createElement("u",null,"각각의 파티션이 서로 다른 DB 서버에 저장 되어있다"),"는 점이다."),"\n",a.createElement(t.blockquote,null,"\n",a.createElement(t.p,null,"Horizontal Partitioning의 경우 각 파티션이 동일한 DB 서버에서 동작한다."),"\n"),"\n",a.createElement(t.p,null,"부하를 분산시킬 수 있으므로 트래픽이 큰 서비스의 경우 샤딩을 잘 이용하면 좋다."),"\n",a.createElement(t.p,null,"샤딩의 경우 partiton key를 shard key라고 부르고, 각 partition을 shard라고 부른다."),"\n",a.createElement(t.h2,{id:"replication이란",style:{position:"relative"}},a.createElement(t.a,{href:"#replication%EC%9D%B4%EB%9E%80","aria-label":"replication이란 permalink",className:"header-links before"},a.createElement(t.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Replication이란?"),"\n",a.createElement(t.p,null,"Master/Primary/Leader 노드가 있고, 이를 바라보고 있는 복사본인 Slave/Secondary/Replica 노드라고 한다."),"\n",a.createElement(t.p,null,"마스터 노드의 변경사항이 생기면 (write) 이를 전파하는데, 그 방식은 동기적일 수도 있고 비동기적으로 구성될 수도 있다. 그리고 read 요청이 올 경우 read replica에게 부하를 분산해줄 수 있다."),"\n",a.createElement(t.p,null,"Fail over에도 능하다. master가 죽었을 경우 다른 replica를 승격시키면 되므로. 이를 통해 ",a.createElement("u",null,"HA (고가용성)"),"을 획득할 수 있다."))}var i=function(e={}){const{wrapper:t}=Object.assign({},(0,l.ah)(),e.components);return t?a.createElement(t,e,a.createElement(r,e)):r(e)},c=n(5670),o=n(1326),h=n(4517),m=n(698),s=n(8627),u=n(662),E=n(1873);const p=({data:e,children:t,serverData:n})=>{const{prevPost:l,nextPost:r}=e,i={...e.mdx.frontmatter,timeToRead:e.mdx.fields.timeToRead};return a.createElement(m.Z,{data:e},a.createElement(c.Z,null,a.createElement(h.Z,i),a.createElement(o.Z,null,t),a.createElement(u.Z,{prev:l,next:r}),a.createElement(s.Z)))};function d(e){return a.createElement(p,e,a.createElement(i,e))}}}]);
//# sourceMappingURL=component---src-templates-article-page-jsx-content-file-path-home-runner-work-leobang-17-github-io-leobang-17-github-io-documents-데이터베이스-database-partitioning-md-fa30f17f3626c6a89137.js.map