"use strict";(self.webpackChunkgatsby_theme_simplex=self.webpackChunkgatsby_theme_simplex||[]).push([[602],{8367:function(e,n,t){t.r(n),t.d(n,{Head:function(){return f.py},default:function(){return p}});var l=t(1151),r=t(7294);function a(e){const n=Object.assign({p:"p",code:"code",strong:"strong",em:"em",ul:"ul",li:"li",pre:"pre",h2:"h2",a:"a",div:"div",blockquote:"blockquote"},(0,l.ah)(),e.components);return r.createElement(r.Fragment,null,r.createElement(n.p,null,r.createElement(n.code,null,"defer")," keyword는 다른 일반적인 programming language에는 등장하지 않는 Go의 특별한 기능이다. ",r.createElement(n.strong,null,"함수가 반환하기 직전에 특정한 코드를 실행하도록 예약"),"하는 기능이다. 말그대로, ",r.createElement(n.em,null,"해당 함수 내의 defer된 동작"),"을 정의한다. 주로 clean-up 작업에 유용하게 쓰인다."),"\n",r.createElement(n.ul,null,"\n",r.createElement(n.li,null,"resource를 정리하거나 (i.e. file, network connection 등을 닫을 때)"),"\n",r.createElement(n.li,null,"Lock을 해제하거나"),"\n",r.createElement(n.li,null,"Callstack을 타고 올라오는 ",r.createElement(n.code,null,"Panic"),"을 처리하는데 사용된다."),"\n"),"\n",r.createElement(n.p,null,r.createElement(n.code,null,"defer")," statement는 ",r.createElement(n.strong,null,"해당 키워드 뒤에 오는 ",r.createElement(n.em,null,"function call"),"을 ”",r.createElement(n.em,null,"defer stack"),"“에 삽입"),"한다. 주의할 점은, function이 아니라 ",r.createElement(n.em,null,"function call"),"이라는 점이다. 실행되는 function의 호출을 defer statement에 제공해야하므로, anonymous function을 ",r.createElement(n.code,null,"defer")," 뒤에 작성하는 경우 ",r.createElement(n.code,null,"()")," 을 붙여 function call임을 명시해야한다."),"\n",r.createElement(n.p,null,"resource 정리의 측면에서 ",r.createElement(n.code,null,"defer"),"가 유용하게 이용되는 용례를 확인해보자."),"\n",r.createElement(n.pre,null,r.createElement(n.code,{className:"language-go"},'func main() {\n\tif err := write("readme.txt", "This is a readme file"); err != nil {\n\t\tlog.Fatal("failed to write file:", err)\n\t}\n}\n\nfunc write(fileName string, text string) error {\n\tfile, err := os.Create(fileName)\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = io.WriteString(file, text)\n\tif err != nil {\n    file.Close()\t\t// < duplicated close call # 1\n\t\treturn err\n\t}\n\tfile.Close()\t\t\t// < duplicated close call # 2\n\treturn nil\n}\n')),"\n",r.createElement(n.ul,null,"\n",r.createElement(n.li,null,r.createElement(n.code,null,"io.WriteString"),"이 실패하든 실패하지 않든, 열린 파일은 함수가 return되기 전에 닫혀야 불필요한 메모리 점유를 피할 수 있다."),"\n",r.createElement(n.li,null,"지금은 2가지 경우의 수만 있지만, 앞으로도 file이 열린 후 발생할 예외처리가 늘어난다면?"),"\n"),"\n",r.createElement(n.p,null,"어차피 함수를 탈출하기 전에 닫아야 하는 것이라면, ",r.createElement(n.code,null,"defer"),"를 이용해 보다 직관적인 코드 작성이 가능하다."),"\n",r.createElement(n.pre,null,r.createElement(n.code,{className:"language-go"},'func main() {\n\tif err := write("readme.txt", "This is a readme file"); err != nil {\n\t\tlog.Fatal("failed to write file:", err)\n\t}\n}\n\nfunc write(fileName string, text string) error {\n\tfile, err := os.Create(fileName)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close()\n\t_, err = io.WriteString(file, text)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n')),"\n",r.createElement(n.h2,{id:"multiple-defer-statements",style:{position:"relative"}},r.createElement(n.a,{href:"#multiple-defer-statements","aria-label":"multiple defer statements permalink",className:"header-links before"},r.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Multiple defer statements"),"\n",r.createElement(n.p,null,"Go runtime은 ",r.createElement(n.code,null,"defer"),"를 관리하기 위해 내부적으로 ",r.createElement(n.em,null,r.createElement(n.code,null,"defer")," stack"),"을 유지한다. 다른 언어와 동일하게 Go에서 함수 호출 시, 각 함수는 자신의 stack frame을 가지게 되며, ",r.createElement(n.code,null,"defer"),"된 함수의 호출이 담긴 ",r.createElement(n.code,null,"defer")," stack은 이 stack frame 내부에 저장되게 된다. (= 각 함수의 stack frame 속에 해당 함수 안에 정의된 defer stack이 유지된다)"),"\n",r.createElement(n.p,null,"이름 그대로, defer stack 역시 LIFO 구조다. 하나의 함수 내에서 여러 개의 ",r.createElement(n.code,null,"defer")," statement가 등장하면 어떻게 될까? 답은 선언된 역순으로 실행된다."),"\n",r.createElement(n.pre,null,r.createElement(n.code,{className:"language-go"},'func main() {\n  defer fmt.Println("one")\n  defer fmt.Println("two")\n  defer fmt.Println("three")\n}\n\n// three two one\n')),"\n",r.createElement(n.p,null,"하나의 함수 안에서 원하는 만큼 ",r.createElement(n.code,null,"defer")," 문을 선언할 수 있다. ",r.createElement(n.strong,null,"모든 ",r.createElement(n.code,null,"defer")," 동작은 선언된 역순으로 실행된다"),"는 것을 기억하자."),"\n",r.createElement(n.p,null,"물론 defer stack이 선언되기 전의 insturction에서 return한다면, 그보다 아래의 defer statement들은 무시된다. defer stack의 head는 실제 runtime에서 return에 걸리는 부분 직전에 선언된 defer statement가 된다."),"\n",r.createElement(n.h2,{id:"panic-handling",style:{position:"relative"}},r.createElement(n.a,{href:"#panic-handling","aria-label":"panic handling permalink",className:"header-links before"},r.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Panic Handling"),"\n",r.createElement(n.p,null,"Go에서 일반적인 Error handling은 Error value를 반환하고 이를 처리하는 방식으로 진행되지만, 다른 일반적인 programming language에서 지원하는 throw 메커니즘과 비슷한 Error 역시 존재한다."),"\n",r.createElement(n.p,null,r.createElement(n.strong,null,"Panic"),"은 타 language의 exception처럼 발생하는 즉시 함수의 실행이 중단되고 함수의 call stack을 거슬어 올라가게 된다. 이 때, ",r.createElement(n.em,null,"stack을 거슬러 올라가며 거치는 함수의 모든 ",r.createElement(n.code,null,"defer")," 문을 실행"),"하게 된다. 이를 통해 프로그램이 비정상 중단되기 전에 중요한 clean-up 작업을 수행할 수 있는 기회를 제공한다."),"\n",r.createElement(n.p,null,"또한 ",r.createElement(n.code,null,"defer")," statement는 그 뒤에 등장하는 function call 속에서 ",r.createElement(n.code,null,"recover()"),"라는 특수한 함수를 호출할 수 있게 한다. ",r.createElement(n.code,null,"recover")," 함수는 말그대로 ",r.createElement(n.code,null,"panic")," 상황을 restore하고 panic에 의해 설정된 error value를 반환한다."),"\n",r.createElement(n.blockquote,null,"\n",r.createElement(n.p,null,r.createElement(n.code,null,"restore")," function은 오직 ",r.createElement(n.code,null,"defer")," 뒤에 오는 function call에서만 유효하다. 다른 곳에서 ",r.createElement(n.code,null,"restore"),"를 호출해도 panic 상황을 복구하지 않는다. 애초에 panic 상황에서는 defer stack 속의 함수만을 호출하므로 생각해보면 당연하다."),"\n"),"\n",r.createElement(n.p,null,"따라서, 일반적인 ",r.createElement(n.code,null,"try···catch")," 메커니즘을 Go에서는 ",r.createElement(n.code,null,"defer"),"와 ",r.createElement(n.code,null,"restore")," 함수를 이용해 구현할 수 있겠다."),"\n",r.createElement(n.pre,null,r.createElement(n.code,{className:"language-go"},'func mayPanic() {\n  panic("something bad happened")\n}\n\nfunc main() {\n  defer func() {\n    if r := recover(); r != nil {\n      fmt.Println("Recovered in main", r)\n    }\n  }()\n  mayPanic()\n  fmt.Println("This statement will not be executed")\n}\n')))}var c=function(e={}){const{wrapper:n}=Object.assign({},(0,l.ah)(),e.components);return n?r.createElement(n,e,r.createElement(a,e)):a(e)},i=t(5670),m=t(1326),u=t(4517),o=t(698),d=t(8627),s=t(662),f=t(1873);const E=({data:e,children:n,serverData:t})=>{const{prevPost:l,nextPost:a}=e,c={...e.mdx.frontmatter,timeToRead:e.mdx.fields.timeToRead};return r.createElement(o.Z,{data:e},r.createElement(i.Z,null,r.createElement(u.Z,c),r.createElement(m.Z,null,n),r.createElement(s.Z,{prev:l,next:a}),r.createElement(d.Z)))};function p(e){return r.createElement(E,e,r.createElement(c,e))}}}]);
//# sourceMappingURL=component---src-templates-article-page-jsx-content-file-path-users-leobang-blog-starter-documents-go-lang-go-defer-statement-md-3814b1f130e98ed72e98.js.map