{"componentChunkName":"component---src-templates-article-page-jsx-content-file-path-users-leobang-blog-starter-documents-java-concurrency-md","path":"/posts/java로-이해하는-concurrency/","result":{"data":{"mdx":{"id":"61279bd1-6449-5f54-bc72-a4500350fd9a","fields":{"slug":"/java로-이해하는-concurrency","timeToRead":37,"categoryDirectory":"/Java/"},"frontmatter":{"title":"Java로 이해하는 Concurrency","createdAt":"December 26, 2022"},"tableOfContents":{"items":[{"url":"#1-process와-thread","title":"1. Process와 Thread","items":[{"items":[{"url":"#processes","title":"Processes"},{"url":"#threads","title":"Threads"}]}]},{"url":"#2-javalangthread","title":"2. ","items":[{"url":"#21-thread-생성하고-구현하기","title":"2.1 Thread 생성하고 구현하기","items":[{"url":"#211-runnable-인터페이스-구현을-통해-생성","title":"2.1.1 Runnable 인터페이스 구현을 통해 생성"},{"url":"#212-thread-클래스-상속하여-생성","title":"2.1.2 Thread 클래스 상속하여 생성"},{"url":"#213-둘-중-어떤-방식을-채택해야할까","title":"2.1.3 둘 중 어떤 방식을 채택해야할까?"}]},{"url":"#22-sleep","title":"2.2 Sleep"},{"url":"#23-interrupts","title":"2.3 Interrupts","items":[{"url":"#231-interrupt에-대응하기","title":"2.3.1 Interrupt에 대응하기","items":[{"url":"#2311-try--catch를-통해-예외처리하기","title":"를 통해 예외처리하기"},{"url":"#2312-threadinterrupted-이용하기","title":" 이용하기"}]}]},{"url":"#24-joins","title":"2.4 Joins"},{"url":"#25-simplethreads-예시","title":"2.5 SimpleThreads 예시"}]},{"url":"#3-synchronization","title":"3. Synchronization","items":[{"url":"#31-thread-interference","title":"3.1 Thread Interference"},{"url":"#32-memory-inconcistency-에러","title":"3.2 Memory Inconcistency 에러"},{"url":"#33-synchronized-메서드","title":"3.3 Synchronized 메서드"},{"url":"#34-intrinsic-lock과-synchronization","title":"3.4 Intrinsic Lock과 Synchronization","items":[{"url":"#synchronized-메서드의-intrinsic-lock","title":"Synchronized 메서드의 intrinsic lock"},{"url":"#synchronized-구문","title":"Synchronized 구문"},{"url":"#reentrant-synchronization","title":"Reentrant Synchronization"}]},{"url":"#35-atomic-접근","title":"3.5 Atomic 접근"}]},{"url":"#4-liveness","title":"4. Liveness","items":[{"url":"#41-deadlock","title":"4.1 Deadlock"},{"url":"#42-starvation","title":"4.2 Starvation"},{"url":"#43-livelock","title":"4.3 Livelock"}]},{"url":"#5-guarded-blocks","title":"5. Guarded Blocks"},{"url":"#6-immutable-objects","title":"6. Immutable Objects"},{"url":"#reference","title":"Reference"}]}},"prevPost":{"fields":{"slug":"/security-filter의-@component를-제거한-이유"},"frontmatter":{"title":"Security Filter의 @Component를 제거한 이유"}},"nextPost":{"fields":{"slug":"/제목-예시-입니다"},"frontmatter":{"title":"제목 예시 입니다."}}},"pageContext":{"id":"61279bd1-6449-5f54-bc72-a4500350fd9a","prevId":"286c36f1-b322-5db2-9719-e4ca8fb7296d","nextId":"e36f5f7a-c503-5b62-aa83-2d6f0a40fd0e","frontmatter":{"title":"Java로 이해하는 Concurrency","createdAt":"2022-12-26T00:00:00.000Z"}}},"staticQueryHashes":["1659129543","1890943840","2045906531","3439177365"],"slicesMap":{}}