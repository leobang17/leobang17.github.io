"use strict";(self.webpackChunkgatsby_theme_simplex=self.webpackChunkgatsby_theme_simplex||[]).push([[2210],{3824:function(e,l,n){n.r(l),n.d(l,{Head:function(){return h.py},default:function(){return B}});var t=n(1151),a=n(7294);function r(e){const l=Object.assign({p:"p",strong:"strong",code:"code",blockquote:"blockquote",ul:"ul",li:"li",h5:"h5",a:"a",div:"div",pre:"pre",table:"table",thead:"thead",tr:"tr",th:"th",tbody:"tbody",td:"td",ol:"ol"},(0,t.ah)(),e.components);return a.createElement(a.Fragment,null,a.createElement(l.p,null,"인덱스란 DB의 ",a.createElement(l.strong,null,"테이블에 대한 검색 속도를 향상시켜주는 자료구조"),"이다."),"\n",a.createElement(l.p,null,"예를들어, ",a.createElement(l.code,null,"SELECT * FROM customer WHERE first_name = 'Minsoo';")," 라는 쿼리가 있다고 해보자. 단순 비교를 통해 색인하는 것이므로 ",a.createElement(l.code,null,"first_name")," column에 index가 걸려있지 않은 경우 DB 엔진은 모든 row를 linear하게 탐색하며 비교할 것이다."),"\n",a.createElement(l.blockquote,null,"\n",a.createElement(l.p,null,"이를 Full Scan 혹은 Table Scan이라고 한다. Full Scan의 시간복잡도는 O(N)이다."),"\n"),"\n",a.createElement(l.p,null,"B-Tree index 기반이라면 탐색을 O(logN)으로 처리할 수 있다. 데이터들은 index에 의해 ",a.createElement("u",null,"정렬된 형태"),"를 갖는다."),"\n",a.createElement(l.p,null,"Index를 사용하는 이유는 다음과 같다."),"\n",a.createElement(l.ul,null,"\n",a.createElement(l.li,null,"특정 조건을 만족하는 Tuple(들)을 빠르게 조회하기 위해서"),"\n",a.createElement(l.li,null,"빠르게 정렬(order by)하거나 그루핑 (group by)하기 위해서"),"\n"),"\n",a.createElement(l.p,null,"데이터들은 기본적으로 파일이므로 HDD 혹은 SSD와 같은 디스크 스토리지에 들어가있지만 ",a.createElement("u",null,"인덱스는 보통 메인 메모리에 올라가 있는다"),". 이게 index가 빠른 또 하나의 이유이기도 하다."),"\n",a.createElement(l.h5,{id:"index를-만들어보자",style:{position:"relative"}},a.createElement(l.a,{href:"#index%EB%A5%BC-%EB%A7%8C%EB%93%A4%EC%96%B4%EB%B3%B4%EC%9E%90","aria-label":"index를 만들어보자 permalink",className:"header-links before"},a.createElement(l.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Index를 만들어보자"),"\n",a.createElement(l.p,null,"index에 대한 column은 중복을 허용할 수도 있다. 이름 같은 경우는 중복될 수도 있잖아. 그러면 mysql같은 경우 다음과 같이 쿼리를 작성하면 된다."),"\n",a.createElement(l.pre,null,a.createElement(l.code,{className:"language-sql"},"CREATE INDEX player_name_idx ON player(name);\n")),"\n",a.createElement(l.ul,null,"\n",a.createElement(l.li,null,"player 테이블의 name attribute에 대해 index를 건다."),"\n",a.createElement(l.li,null,"이후부터는 name을 조건 탐색하는 경우 index가 걸려서 색인하게 된다."),"\n"),"\n",a.createElement(l.pre,null,a.createElement(l.code,{className:"language-sql"},"CREATE UNIQUE INDEX team_id_backnumber_idx ON player(team_id, backnumber);\n")),"\n",a.createElement(l.ul,null,"\n",a.createElement(l.li,null,"해당 attribute가 row를 특정할 수 있다면 UNIQUE 인덱스를 생성해줄 수 있다."),"\n",a.createElement(l.li,null,"이렇게 두 개 이상의 attribute로 이루어진 index를 multicolumn index, composite index라고 한다."),"\n"),"\n",a.createElement(l.p,null,"이렇게 table이 생성된 이후에 쿼리를 통해 인덱스를 만들어도 되지만 table을 정의할 때부터 index를 정의할 수도 있다."),"\n",a.createElement(l.p,null,a.createElement("u",null,"Primary Key의 경우 index가 자동으로 생성"),"된다."),"\n",a.createElement(l.h5,{id:"b-tree-기반-index가-어떻게-동작하는지",style:{position:"relative"}},a.createElement(l.a,{href:"#b-tree-%EA%B8%B0%EB%B0%98-index%EA%B0%80-%EC%96%B4%EB%96%BB%EA%B2%8C-%EB%8F%99%EC%9E%91%ED%95%98%EB%8A%94%EC%A7%80","aria-label":"b tree 기반 index가 어떻게 동작하는지 permalink",className:"header-links before"},a.createElement(l.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"B Tree 기반 Index가 어떻게 동작하는지"),"\n",a.createElement(l.p,null,"인덱스를 걸어준 attribute의 column을 복사해서 정렬해놓는다. 그리고 ptr 데이터를 가지고 있음. 이 ptr이 원래 table의 어떤 tuple을 가리키고 있는지에 대한 정보를 저장한다."),"\n",a.createElement(l.p,null,"만약 ",a.createElement(l.code,null,"SELECT * FROM members WHERE a = 7 AND b = 95;"),"의 쿼리를 실행하는데 ",a.createElement(l.code,null,"a")," attribute에만 인덱스가 걸려있다면?"),"\n",a.createElement(l.ul,null,"\n",a.createElement(l.li,null,"a의 조건에 맞는 tuple을 찾는데는 logN의 시간복잡도가 필요하지만, a 조건에 부합하는 tuple 안에서는 또다시 full scan을 해주어야 한다."),"\n",a.createElement(l.li,null,"따라서 a, b가 같이 묶여서 많이 조회된다면 composite index를 만드는 것을 고려해보아도 좋다.","\n",a.createElement(l.ul,null,"\n",a.createElement(l.li,null,"composite index의 경우 ",a.createElement(l.code,null,"CREATE INDEX(a, b)")," 쿼리의 왼쪽부터 정렬해준다."),"\n",a.createElement(l.li,null,"a부터 정렬하고 a의 값이 같다면 그 안에서 b를 기준으로 정렬해주는 것."),"\n",a.createElement(l.li,null,"index의 attribute 순서가 다르다!"),"\n"),"\n"),"\n"),"\n",a.createElement(l.p,null,"만약 a와 b를 섞어 composite index를 걸었는데, b를 조건으로만 색인을 한다면?"),"\n",a.createElement(l.ul,null,"\n",a.createElement(l.li,null,"성능이 안나온다. 먼저 a가 정렬되어있기 때문. 사실상 정렬되어있지 않는 상태다."),"\n",a.createElement(l.li,null,"대부분 Full Scan하게 된다."),"\n"),"\n",a.createElement(l.p,null,a.createElement(l.strong,null,"정리하자면, 많이 사용되는 query에 맞추어 적절하게 index를 걸어주면 query의 속도를 개선할 수 있다.")),"\n",a.createElement(l.p,null,"player table이 다음과 같다고 하자."),"\n",a.createElement(l.table,null,a.createElement(l.thead,null,a.createElement(l.tr,null,a.createElement(l.th,null,"id"),a.createElement(l.th,null,"name"),a.createElement(l.th,null,"team_id"),a.createElement(l.th,null,"backnumber"))),a.createElement(l.tbody,null,a.createElement(l.tr,null,a.createElement(l.td,null,"···"),a.createElement(l.td,null,"···"),a.createElement(l.td,null,"···"),a.createElement(l.td,null,"···")))),"\n",a.createElement(l.p,null,"index가 걸려있는 항목은 다음과 같다."),"\n",a.createElement(l.ul,null,"\n",a.createElement(l.li,null,"id: pk이므로 기본으로 걸려있음"),"\n",a.createElement(l.li,null,"name"),"\n",a.createElement(l.li,null,"(team_id, backnumber)"),"\n",a.createElement(l.li,null,"backnumber"),"\n"),"\n",a.createElement(l.p,null,"만약 이 상황에서 ",a.createElement(l.code,null,"SELECT * FROM player WHERE backnumber = 7;")," 쿼리를 실행하면 어떻게 될까? ",a.createElement(l.code,null,"backnumber")," attribute를 이용하는 index는 2개니까! 이 때는 sql optimizer가 적합한 index를 사용해 처리한다."),"\n",a.createElement(l.p,null,"근데 가끔씩은 이 optimizer도 빠가가 되어 인덱스를 잘못 선택하는 경우가 있다. 이 때는 직접 이용할 index를 골라 쿼리를 실행할 수도 있다."),"\n",a.createElement(l.pre,null,a.createElement(l.code,{className:"language-sql"},"SELECT * FROM player USE INDEX (backnumber_idx) WHERE backnumber = 7;\n혹은\nSELECT * FROM player FORCE INDEX (backnumber_idx) WHERE backnumber = 7;\n")),"\n",a.createElement(l.ul,null,"\n",a.createElement(l.li,null,a.createElement(l.code,null,"USE INDEX")," 키워드의 경우 권장 사항의 느낌. ‘optimizer에게 가급적 이 index를 이용해달라’ 부탁하는 느낌"),"\n",a.createElement(l.li,null,"무조건 이용하도록 하는 키워드는 ",a.createElement(l.code,null,"FORCE INDEX")),"\n"),"\n",a.createElement(l.h5,{id:"index는-막-만들어도-괜찮을까-성능-향상에-좋은-것-같은데",style:{position:"relative"}},a.createElement(l.a,{href:"#index%EB%8A%94-%EB%A7%89-%EB%A7%8C%EB%93%A4%EC%96%B4%EB%8F%84-%EA%B4%9C%EC%B0%AE%EC%9D%84%EA%B9%8C-%EC%84%B1%EB%8A%A5-%ED%96%A5%EC%83%81%EC%97%90-%EC%A2%8B%EC%9D%80-%EA%B2%83-%EA%B0%99%EC%9D%80%EB%8D%B0","aria-label":"index는 막 만들어도 괜찮을까 성능 향상에 좋은 것 같은데 permalink",className:"header-links before"},a.createElement(l.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Index는 막 만들어도 괜찮을까? 성능 향상에 좋은 것 같은데."),"\n",a.createElement(l.p,null,"Index에는 여러 단점도 존재한다."),"\n",a.createElement(l.ol,null,"\n",a.createElement(l.li,null,"index를 위한 추가적인 저장공간이 필요하다."),"\n",a.createElement(l.li,null,"index를 관리하기 위해 추가 작업이 필요하다."),"\n"),"\n",a.createElement(l.p,null,"Index를 생성해줄 때마다 Index를 위한 부가적인 자료구조가 담긴 테이블도 생성된다. 그 것도 모든 column의 값을 복사해서! 그리고 Index 자료구조는 ",a.createElement("u",null,"메인 메모리에 상주할 가능성이 높기 때문에 불필요한 메모리 점유를 초래"),"할 수도 있다."),"\n",a.createElement(l.p,null,"또한 index는 항상 정렬된 상태로 유지해야하기 때문에 index가 적용된 column에 INSERT, UPDATE, DELETE를 수행하면 정렬을 맞추기 위한 추가 작업이 필요하다."),"\n",a.createElement(l.ul,null,"\n",a.createElement(l.li,null,"index가 걸린 table이 커질수록 write 작업에 대한 overhead도 늘어나게 된다."),"\n",a.createElement(l.li,null,"또한 데이터의 index를 ",a.createElement("u",null,"제거하는 것이 아니라 ‘사용하지 않음’으로 처리하고 남겨"),"두기 때문에 UPDATE 작업이 많은 경우 실제 데이터 크기에 비해 index가 과도하게 커지는 문제점이 나타날 수 있다."),"\n"),"\n",a.createElement(l.p,null,"따라서 불필요한 index는 만들지 않는 것이 중요하다."),"\n",a.createElement(l.h5,{id:"index가-오히려-독이-되는-경우--full-scan이-더-나은-경우",style:{position:"relative"}},a.createElement(l.a,{href:"#index%EA%B0%80-%EC%98%A4%ED%9E%88%EB%A0%A4-%EB%8F%85%EC%9D%B4-%EB%90%98%EB%8A%94-%EA%B2%BD%EC%9A%B0--full-scan%EC%9D%B4-%EB%8D%94-%EB%82%98%EC%9D%80-%EA%B2%BD%EC%9A%B0","aria-label":"index가 오히려 독이 되는 경우  full scan이 더 나은 경우 permalink",className:"header-links before"},a.createElement(l.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Index가 오히려 독이 되는 경우 = Full Scan이 더 나은 경우"),"\n",a.createElement(l.p,null,"table에 데이터가 조금만 있을 경우에는 성능 차이가 거의 없다."),"\n",a.createElement(l.p,null,"혹은 조회하려는 데이터가 테이블의 상당 부분을 차지할 때도 오히려 성능 저하를 초래한다."),"\n",a.createElement(l.ul,null,"\n",a.createElement(l.li,null,"만약 ",a.createElement(l.code,null,"SELECT * FROM customer WHERE mobile_carrier = 'SK';")," 라는 쿼리를 실행해야하는데, SK를 이용하는 이용자가 90% 이상일 경우 full scan하는 것이 더 낫다."),"\n",a.createElement(l.li,null,"물론 full scan할지는 optimizer가 판단한다."),"\n",a.createElement(l.li,null,"성별, 나이와 같이 range가 적은 column의 경우에도 index를 읽고 나서 다시 많은 데이터를 조회해야하므로 비효율적이다."),"\n"),"\n",a.createElement(l.h5,{id:"covering-index-스킬",style:{position:"relative"}},a.createElement(l.a,{href:"#covering-index-%EC%8A%A4%ED%82%AC","aria-label":"covering index 스킬 permalink",className:"header-links before"},a.createElement(l.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Covering Index 스킬!"),"\n",a.createElement(l.p,null,"만약 ",a.createElement(l.code,null,"SELECT team_id, backnumber FROM player WHERE team_id = 5;")," 라는 쿼리를 실행하는데, 해당 ",a.createElement(l.code,null,"player")," 테이블에 ",a.createElement(l.code,null,"team_id"),"와 ",a.createElement(l.code,null,"backnumber"),"를 모은 composite index가 걸려있다고 해보자."),"\n",a.createElement(l.p,null,"이미 index 테이블에 team_id와 backnumber 값은 정렬된 채로 저장되어있는 상태이다. 굳이 B Tree를 색인한 후에 ptr이 가리키는 tuple로 돌아와서 값을 줄 필요 없이, index 테이블에서 바로 꺼내올 수 있는 상태!"),"\n",a.createElement(l.ul,null,"\n",a.createElement(l.li,null,"조회하려는 attribute들을 index가 모두 cover하고 있는 경우, covering index를 이용하면 조회 속도가 더 빨라진다."),"\n"),"\n",a.createElement(l.h5,{id:"index의-구현-방식",style:{position:"relative"}},a.createElement(l.a,{href:"#index%EC%9D%98-%EA%B5%AC%ED%98%84-%EB%B0%A9%EC%8B%9D","aria-label":"index의 구현 방식 permalink",className:"header-links before"},a.createElement(l.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Index의 구현 방식"),"\n",a.createElement(l.p,null,"위에서는 B Tree를 말했지만 Hash를 이용해 구현한 Hash Index도 존재한다."),"\n",a.createElement(l.ul,null,"\n",a.createElement(l.li,null,"조회 시간복잡도가 O(1)"),"\n"),"\n",a.createElement(l.p,null,"하지만 단점도 있다."),"\n",a.createElement(l.ul,null,"\n",a.createElement(l.li,null,"rehashing에 대한 부담"),"\n",a.createElement(l.li,null,"equality 비교만 가능하다. range 비교는 불가능"),"\n",a.createElement(l.li,null,"multicolumn index의 경우 전체 attributes에 대한 조회만 가능하다.","\n",a.createElement(l.ul,null,"\n",a.createElement(l.li,null,"(a, b)로 composite했다면, 조회 조건에 a와 b가 모두 들어가는 경우에만 이용할 수 있다."),"\n",a.createElement(l.li,null,"b tree의 경우 (a, b) composite여도 a로만 검색할 수도 있었음."),"\n"),"\n"),"\n"),"\n",a.createElement(l.p,null,"hash table 자료구조의 경우 array로 되어있는데, array가 늘어날 경우 어느 지점에서는 이 data size를 늘려주어야 하는데, 이를 rehashing 이라고 한다."),"\n",a.createElement(l.ul,null,"\n",a.createElement(l.li,null,"트래픽이 막 몰려오는데 rehashing 하는데에 대한 부담"),"\n"),"\n",a.createElement(l.h5,{id:"order-by나-group-by에도-index가-사용될-수-있다",style:{position:"relative"}},a.createElement(l.a,{href:"#order-by%EB%82%98-group-by%EC%97%90%EB%8F%84-index%EA%B0%80-%EC%82%AC%EC%9A%A9%EB%90%A0-%EC%88%98-%EC%9E%88%EB%8B%A4","aria-label":"order by나 group by에도 index가 사용될 수 있다 permalink",className:"header-links before"},a.createElement(l.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"order by나 group by에도 index가 사용될 수 있다"),"\n",a.createElement(l.h5,{id:"foreign-key에는-index가-자동으로-생성되지-않을-수-있다",style:{position:"relative"}},a.createElement(l.a,{href:"#foreign-key%EC%97%90%EB%8A%94-index%EA%B0%80-%EC%9E%90%EB%8F%99%EC%9C%BC%EB%A1%9C-%EC%83%9D%EC%84%B1%EB%90%98%EC%A7%80-%EC%95%8A%EC%9D%84-%EC%88%98-%EC%9E%88%EB%8B%A4","aria-label":"foreign key에는 index가 자동으로 생성되지 않을 수 있다 permalink",className:"header-links before"},a.createElement(l.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"foreign key에는 index가 자동으로 생성되지 않을 수 있다"),"\n",a.createElement(l.p,null,"join 관련해서 성능 문제가 나타날 수 있기 때문"),"\n",a.createElement(l.h5,{id:"이미-data가-몇-백만-건-이상-있는-테이블에-index를-생성하는-경우-시간이-몇-분-이상-소요될-수-있고-db-성능에-안좋은-영향을-줄-수-있다",style:{position:"relative"}},a.createElement(l.a,{href:"#%EC%9D%B4%EB%AF%B8-data%EA%B0%80-%EB%AA%87-%EB%B0%B1%EB%A7%8C-%EA%B1%B4-%EC%9D%B4%EC%83%81-%EC%9E%88%EB%8A%94-%ED%85%8C%EC%9D%B4%EB%B8%94%EC%97%90-index%EB%A5%BC-%EC%83%9D%EC%84%B1%ED%95%98%EB%8A%94-%EA%B2%BD%EC%9A%B0-%EC%8B%9C%EA%B0%84%EC%9D%B4-%EB%AA%87-%EB%B6%84-%EC%9D%B4%EC%83%81-%EC%86%8C%EC%9A%94%EB%90%A0-%EC%88%98-%EC%9E%88%EA%B3%A0-db-%EC%84%B1%EB%8A%A5%EC%97%90-%EC%95%88%EC%A2%8B%EC%9D%80-%EC%98%81%ED%96%A5%EC%9D%84-%EC%A4%84-%EC%88%98-%EC%9E%88%EB%8B%A4","aria-label":"이미 data가 몇 백만 건 이상 있는 테이블에 index를 생성하는 경우 시간이 몇 분 이상 소요될 수 있고 db 성능에 안좋은 영향을 줄 수 있다 permalink",className:"header-links before"},a.createElement(l.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"이미 Data가 몇 백만 건 이상 있는 테이블에 index를 생성하는 경우 시간이 몇 분 이상 소요될 수 있고, DB 성능에 안좋은 영향을 줄 수 있다."),"\n",a.createElement(l.p,null,"그 시간동안 DB 성능에 안좋은 영향을 줄 수 있겠지? 그냥 read 쿼리면 괜찮은데 index를 생성하는 도중에 write 쿼리가 많이 날아오는 상황이라면··· 더 느려질 것."),"\n",a.createElement(l.p,null,"트래픽이 적은 시간에 하길 추천."))}var E=function(e={}){const{wrapper:l}=Object.assign({},(0,t.ah)(),e.components);return l?a.createElement(l,e,a.createElement(r,e)):r(e)},c=n(5670),i=n(1326),m=n(4517),u=n(698),d=n(8627),o=n(662),h=n(1873);const s=({data:e,children:l,serverData:n})=>{const{prevPost:t,nextPost:r}=e,E={...e.mdx.frontmatter,timeToRead:e.mdx.fields.timeToRead};return a.createElement(u.Z,{data:e},a.createElement(c.Z,null,a.createElement(m.Z,E),a.createElement(i.Z,null,l),a.createElement(o.Z,{prev:t,next:r}),a.createElement(d.Z)))};function B(e){return a.createElement(s,e,a.createElement(E,e))}}}]);
//# sourceMappingURL=component---src-templates-article-page-jsx-content-file-path-users-leobang-blog-starter-documents-데이터베이스-database-index-md-fda7850ce22f91ae5e16.js.map