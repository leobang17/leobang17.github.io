---
title: "HTTP를 Stateful하게 - JWT"
createdAt: 2023-01-06
---

HTTP의 인증 state를 유지하기 위한 방식하면 꼭 등장하는 셋이 cookie, session 그리고 JWT이다. 사실 JWT 그 자체가 HTTP를 stateful하게 만들어 준다기 보다는 그냥 HTTP 표준의 authorization header에 token 기반으로 인가 state를 유지하는 방식 중, JWT 표준을 따르는 token을 이용한 것 뿐이지만...

> Base64URL인코딩된 JSON 객체를 토큰으로 이용하는 표준을 JWT라고 한다. 

**JWT가 Base64url 인코딩을 이용하는 이유**

Base64 인코딩의 경우 `“+”, “/”, “=”`이 포함되지만 JWT는 URI에서 파라미터로 사용할 수 있도록 URL-Safe 한 Base64url 인코딩을 사용한다.



##### JWT는 그 자체로 암호화되어있다? 

ㄴㄴ JWT는 그냥 인코딩된 문자열일 뿐이다. 이를 올바른 방식으로 디코딩한다면 누구나 내용물을 볼 수 있다. 따라서 민감한 정보를 그대로 JWT payload에 담아서 주고 받으면 안된다.

cookie 탈취를 통해 해당 토큰을 얻게된다면, 단순히 디코딩하는 것 만으로도 안의 정보를 확인할 수 있다···



##### JWT의 구조

Header, Payload (= claim), signature로 이루어져 있다. 각 part는 `.`으로 구분된다.

Header

- 해당 토큰(문자열)이 JWT 형식임을 표기
- 어떤 알고리즘을 이용해 signature를 작성했는지 표기

Payload

- 주고 받아야할, JWT가 담고 있는 정보들을 때려박는다.
- RFC에 지정된 표준 claim도 있지만 원하는 key value로 claim을 전달해도 된다.
- payload가 비대해질 수록 암/복호화에 시간이 오래걸리므로 필요한 정보만 담도록 하자.

Signature

- Header와 Payload의 값을 특정 암호화 알고리즘 + secret key를 활용해 암호화한 것.
- 해시 알고리즘이기 때문에 header 혹은 payload의 조작 여부를 확인할 수 있다.
- 대칭키와 비대칭키 암호화 방식을 모두 이용 가능하다. 



##### 대칭키 암호화? 비대칭키 암호화? 

토큰 위/변조만 필요하다면 대칭키 암호화 알고리즘으로도 충분하다. 만약 디지털 서명이 필요하다면 비대칭키 방식을 활용해야겠지만, 비대칭키는 암/복호화에 더욱 많은 CPU 타임을 소모한다 = 느리다. 



##### JWT의 장점

1. I/O 타임을 줄일 수 있다.  

일단 Session은 서버 애플리케이션이 하나의 instance에서만 실행되는게 아니라면, 애플리케이션 프로세스 외부의 DB 서버를 바라보고 있을 것이다. 혹은 session affinity 설정을 통해 애플리케이션 프로세스 안에서 해결할 수도···! 

어쨌든 session DB가 InMemory DB던 SSD까지 접근하는 DB던 네트워크 I/O가 발생하고, 특정 DB에 부하를 주는 것이므로 부담이 되는 일이다. 

2. 대칭키 암호화는 비교적 빠른 편이다.

암/복호화 이후에는 claim에 대한 값 검증만 수행하면 된다. 이 과정은 꽤 빠르게 이루어질 수 있다.

3. Server는 Stateless를 획득할 수 있다.

이용자에 대한 상태를 저장해둘 필요가 없다. 



##### JWT의 단점

1. 토큰이 길어 네트워크 부하를 늘린다.

Session은 네트워크 요청 시에 cookie를 이용해 session key만 주고 받는다. session key가 일반적으로 JWT보다는 길이가 짧으므로 네트워크 부하를 높인다.

2. 이미 생성한 토큰은 변경 불가능하다.

JWT는 일단 생성하면 내용물을 변경할 수 없다. 좋은 점도 있지만 문제는 이미 발급한 토큰은 만료기한 동안 쭉 활성화된 토큰이 된다.

만료기한이 1일 남은 로그인용 JWT가 존재하고, 유저가 로그아웃을 원한다. 물론 로그아웃 로직을 수행하는 방식은 클라이언트와 조율해서 간단히 구현할 수 있지만, 어쨌든 해당 토큰은 만료기한까지 이용할 수 있는 상태이다.

세션을 이용한다면 단순히 해당 세션키를 지워버리면 된다. 하지만 JWT를 진정한 의미로 '만료'시키려면 JWT 역시 세션으로 저장하고 해당 jwt가 만료되었는지를 체크해야할 것이다. 

내부 상태를 변경하고자 하는 것 역시 문제가 된다. JWT는 변경할 수 없으므로 새로운 상태로 갱신한 JWT를 새로 발급해야하는데, 그러면 잠시동안이겠지만 한 유저에게 할당된 활성화된 토큰이 2개 이상으로 늘어나게 된다. 취약점이 산술적으로 상승하는 셈.

3. 만료기한을 매우 짧게 잡다보니 refresh 전략이 중요하다···

