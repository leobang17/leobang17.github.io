"use strict";(self.webpackChunkgatsby_theme_simplex=self.webpackChunkgatsby_theme_simplex||[]).push([[8097],{2748:function(e,n,l){l.r(n),l.d(n,{Head:function(){return d.py},default:function(){return E}});var t=l(1151),a=l(7294);function r(e){const n=Object.assign({h2:"h2",a:"a",div:"div",p:"p",code:"code",h4:"h4",ul:"ul",li:"li",ol:"ol",pre:"pre"},(0,t.ah)(),e.components);return a.createElement(a.Fragment,null,a.createElement(n.h2,{id:"문제",style:{position:"relative"}},a.createElement(n.a,{href:"#%EB%AC%B8%EC%A0%9C","aria-label":"문제 permalink",className:"header-links before"},a.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"문제"),"\n",a.createElement(n.p,null,"정수 배열 ",a.createElement(n.code,null,"nums"),"가 주어진다. 배열의 첫번째 인덱스로부터 시작해 jump해서 마지막 인덱스까지 도달하면 게임에서 승리한다.\n",a.createElement(n.code,null,"nums"),"의 각 원소는 최대 jump 거리를 나타낸다. (최대 jump 거리보다 적게 jump하는 것을 선택할 수도 있다.)"),"\n",a.createElement(n.p,null,"마지막 인덱스에 도달할 수 있다면 ",a.createElement(n.code,null,"True"),"를 반환하고, 그렇지 않다면 ",a.createElement(n.code,null,"False"),"를 반환하라."),"\n",a.createElement(n.h4,{id:"constraints",style:{position:"relative"}},a.createElement(n.a,{href:"#constraints","aria-label":"constraints permalink",className:"header-links before"},a.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Constraints"),"\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,a.createElement(n.code,null,"1 <= nums.length <= 10^4")),"\n",a.createElement(n.li,null,a.createElement(n.code,null,"0 <= nums[i] <= 10^5")),"\n"),"\n",a.createElement(n.h2,{id:"approach---greedy1-내-풀이",style:{position:"relative"}},a.createElement(n.a,{href:"#approach---greedy1-%EB%82%B4-%ED%92%80%EC%9D%B4","aria-label":"approach   greedy1 내 풀이 permalink",className:"header-links before"},a.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Approach - Greedy1 (내 풀이)"),"\n",a.createElement(n.p,null,"게임의 승리 조건은 다음과 같다."),"\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,"배열의 마지막 index, 혹은 그 이상을 갈 수 있을 경우\n게임의 패배 조건은 다음과 같다."),"\n",a.createElement(n.li,null,"도착한 index의 jump 가능 거리가 ",a.createElement(n.code,null,"0"),"일 경우"),"\n"),"\n",a.createElement(n.p,null,"while 문을 이용해 pointer를 옮겨가며 배열을 순회한다.\n포인터가 가리키는 다음 index를 계산하는 알고리즘은 다음과 같았다."),"\n",a.createElement(n.ol,null,"\n",a.createElement(n.li,null,"해당 index에서 옮겨갈 수 있는 모든 노드를 for문으로 순차적으로 확인한다."),"\n",a.createElement(n.li,null,"각 노드가 갈 수 있는 최대 거리를 확인한 후, 가장 멀리갈 수 있는 노드를 다음 pointer로 갱신한다."),"\n",a.createElement(n.li,null,"이 때 최대 거리가 같다면 현재 index로부터 가장 먼 노드를 선택한다."),"\n"),"\n",a.createElement(n.p,null,"while문으로 순회하면서 그 안에서도 for loop을 돌기 때문에 ",a.createElement(n.code,null,"O(N^2)"),"의 시간 복잡도를 가진다고 생각할 수도 있지만 pointer가 한번 방문했던 곳을 다시 방문하는 일은 최대 2번이므로 (최대 거리를 체크할 때 한번, 앞선 노드가 최대 거리일 경우 for loop을 돌 때 다시 한번) ",a.createElement(n.code,null,"O(N)"),"의 시간복잡도를 가진다."),"\n",a.createElement(n.p,null,"방문 표시로 최대 거리 노드에서 탈락한 인덱스들을 표시해준다면 완벽히 ",a.createElement(n.code,null,"O(N)"),"의 시간복잡도를 가질 수 있을 듯?"),"\n",a.createElement(n.h4,{id:"complexity",style:{position:"relative"}},a.createElement(n.a,{href:"#complexity","aria-label":"complexity permalink",className:"header-links before"},a.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Complexity"),"\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,"time complexity: ",a.createElement(n.code,null,"O(N)")),"\n",a.createElement(n.li,null,"space complexity: ",a.createElement(n.code,null,"O(1)")),"\n"),"\n",a.createElement(n.h4,{id:"code",style:{position:"relative"}},a.createElement(n.a,{href:"#code","aria-label":"code permalink",className:"header-links before"},a.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Code"),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-python"},"class Solution:\n    def canJump(self, nums: List[int]) -> bool:\n        ptr = 0 \n        \n        # O(N)\n        while ptr < len(nums):\n            if ptr == len(nums) - 1:  # 성공 \n                return True\n            elif nums[ptr] == 0:  # 실패\n                return False\n            \n            biggest = 0 # 가장 멀리 갈 수 있는 노드는 어디까지 갈 수 있는지\n            \n            if ptr + nums[ptr] >= len(nums):\n                return True\n                \n            for i in range(ptr + 1, ptr + nums[ptr] + 1):\n                if i + nums[i] >= biggest:\n                    biggest = i + nums[i]\n                    ptr = i\n            \n        return True\n")),"\n",a.createElement(n.h2,{id:"approach---greedy2-neetcode-솔루션",style:{position:"relative"}},a.createElement(n.a,{href:"#approach---greedy2-neetcode-%EC%86%94%EB%A3%A8%EC%85%98","aria-label":"approach   greedy2 neetcode 솔루션 permalink",className:"header-links before"},a.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Approach - Greedy2 (NeetCode 솔루션)"),"\n",a.createElement(n.p,null,a.createElement(n.a,{href:"https://www.youtube.com/watch?v=Yan0cv2cLy8",target:"_self",rel:"nofollow"},"NeetCode의 greedy 해결법"),"을 찾아보았다."),"\n",a.createElement(n.p,null,"로직은 훨씬 단순하다. 배열의 마지막에서부터 순회하며 성공지점을 계속해서 앞당기는 방식이다."),"\n",a.createElement(n.ol,null,"\n",a.createElement(n.li,null,"배열의 마지막에서부터 처음으로 순회한다."),"\n",a.createElement(n.li,null,"순회하는 노드에서 성공지점에 도달할 수 있다면, 해당 노드를 성공지점으로 갱신한다."),"\n",a.createElement(n.li,null,"순회가 끝난 후 성공지점이 0이라면 출발점에서 끝까지 도달할 수 있다는 것을 뜻하므로 ",a.createElement(n.code,null,"True"),"를 반환하고, 그 외에는 ",a.createElement(n.code,null,"False"),"를 반환한다."),"\n"),"\n",a.createElement(n.p,null,"깔끔.."),"\n",a.createElement(n.h4,{id:"complexity-1",style:{position:"relative"}},a.createElement(n.a,{href:"#complexity-1","aria-label":"complexity 1 permalink",className:"header-links before"},a.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Complexity"),"\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,"time complexity: ",a.createElement(n.code,null,"O(N)")),"\n",a.createElement(n.li,null,"space complexity: ",a.createElement(n.code,null,"O(1)")),"\n"),"\n",a.createElement(n.h4,{id:"code-1",style:{position:"relative"}},a.createElement(n.a,{href:"#code-1","aria-label":"code 1 permalink",className:"header-links before"},a.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Code"),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-python"},"class Solution:\n    def canJump(self, nums: List[int]) -> bool:\n        ptr = len(nums) - 2 # 순회 포인터\n        goal = len(nums) - 1  # 성공지점\n        \n        while ptr >= 0:\n            if goal <= ptr + nums[ptr]:\n                goal = ptr\n            ptr -= 1\n            \n        if goal == 0:\n            return True\n        else:\n            return False\n")))}var c=function(e={}){const{wrapper:n}=Object.assign({},(0,t.ah)(),e.components);return n?a.createElement(n,e,a.createElement(r,e)):r(e)},i=l(5670),o=l(1326),m=l(4517),s=l(698),h=l(8627),u=l(662),d=l(1873);const p=({data:e,children:n,serverData:l})=>{const{prevPost:t,nextPost:r}=e,c={...e.mdx.frontmatter,timeToRead:e.mdx.fields.timeToRead};return a.createElement(s.Z,{data:e},a.createElement(i.Z,null,a.createElement(m.Z,c),a.createElement(o.Z,null,n),a.createElement(u.Z,{prev:t,next:r}),a.createElement(h.Z)))};function E(e){return a.createElement(p,e,a.createElement(c,e))}}}]);
//# sourceMappingURL=component---src-templates-article-page-jsx-content-file-path-home-runner-work-leobang-17-github-io-leobang-17-github-io-documents-algorithm-55-jump-game-md-35e5c18b1e451c58bb70.js.map