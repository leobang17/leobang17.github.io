"use strict";(self.webpackChunkgatsby_theme_simplex=self.webpackChunkgatsby_theme_simplex||[]).push([[4256],{2044:function(e,n,l){l.r(n),l.d(n,{Head:function(){return h.py},default:function(){return p}});var t=l(1151),a=l(7294);function c(e){const n=Object.assign({h2:"h2",a:"a",div:"div",p:"p",pre:"pre",code:"code",ul:"ul",li:"li",h5:"h5",ol:"ol",em:"em",h4:"h4",blockquote:"blockquote"},(0,t.ah)(),e.components);return a.createElement(a.Fragment,null,a.createElement(n.h2,{id:"동기화-synchronization",style:{position:"relative"}},a.createElement(n.a,{href:"#%EB%8F%99%EA%B8%B0%ED%99%94-synchronization","aria-label":"동기화 synchronization permalink",className:"header-links before"},a.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"동기화 Synchronization"),"\n",a.createElement(n.p,null,"상한 귤을 골라내보자! thread 2개를 이용해서."),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-java"},"for (귤 in 귤박스) {\n  if (귤.상태 is 불량) {\n    badCounter.increment();\n  }\n}\n\npublic class Counter {\n  private int state = 0;\n  public void increment() { state ++; }\n  public int get() { return state; }\n} \n")),"\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,"\n",a.createElement(n.p,null,a.createElement(n.code,null,"state ++;")," 는 한 줄의 코드 같지만, CPU 레벨에서는 다음의 instruction들로 컴파일된다."),"\n"),"\n",a.createElement(n.li,null,"\n",a.createElement(n.pre,null,a.createElement(n.code,null,"LOAD state to R1 // 메모리의 state 변수 값을 레지스터로 로드하고, \nR1 = R1 + 1\t// 레지스터에 1을 더하고\nSTORE R1 to state\t// 레지스터의 값을 다시 메모리의 state 변수로 전달.\n")),"\n"),"\n",a.createElement(n.li,null,"\n",a.createElement(n.p,null,"만약 두번째 줄에서 context switching이 일어난다면? 헛더하는 일이 생긴다."),"\n"),"\n"),"\n",a.createElement(n.h5,{id:"race-condition이란",style:{position:"relative"}},a.createElement(n.a,{href:"#race-condition%EC%9D%B4%EB%9E%80","aria-label":"race condition이란 permalink",className:"header-links before"},a.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Race Condition이란?"),"\n",a.createElement(n.p,null,"위와 같이, 여러 프로세스/thread가 동시에 같은 데이터를 조작할 때 ",a.createElement("u",null,"타이밍이나 접근 순서에 따라 결과가 달라질 수 있는 상황"),"을 말한다."),"\n",a.createElement(n.h5,{id:"동기화-synchronization란",style:{position:"relative"}},a.createElement(n.a,{href:"#%EB%8F%99%EA%B8%B0%ED%99%94-synchronization%EB%9E%80","aria-label":"동기화 synchronization란 permalink",className:"header-links before"},a.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"동기화 (Synchronization)란?"),"\n",a.createElement(n.p,null,"여러 프로세스/스레드를 동시에 실행해도 race condition 없이 공유 데이터의 일관성을 유지하는 것."),"\n",a.createElement(n.p,null,"그렇다면 어떻게 동기화 시킬 수 있을까?"),"\n",a.createElement(n.ol,null,"\n",a.createElement(n.li,null,"공유 데이터에 접근하는 동안은 context switching을 멈추자! (X)","\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,"싱글코어에서는 가능하지만 멀티코어 이상의 병렬 실행환경이 되면 context switching을 막는 것 만으로는 race condition을 해결할 수 없다."),"\n"),"\n"),"\n",a.createElement(n.li,null,"race condition이 일어나는 구간을 동시에 하나의 thread만 실행할 수 있도록 하자! (O)","\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,"해당 구간에 진입할 수 있는 thread는 같은 시점에 하나 밖에 없다."),"\n",a.createElement(n.li,null,"이 특정 구간을 ",a.createElement("u",null,"Critical Section (임계영역)"),"이라고 부른다.","\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,a.createElement(n.em,null,"공유 데이터의 일관성을 보장하기 위해 하나의 프로세스/스레드만 진입해서 실행가능한 영역")),"\n"),"\n"),"\n"),"\n"),"\n"),"\n",a.createElement(n.h5,{id:"critical-section-문제를-해결하기-위해-필요한-조건은-다음-세가지와-같다",style:{position:"relative"}},a.createElement(n.a,{href:"#critical-section-%EB%AC%B8%EC%A0%9C%EB%A5%BC-%ED%95%B4%EA%B2%B0%ED%95%98%EA%B8%B0-%EC%9C%84%ED%95%B4-%ED%95%84%EC%9A%94%ED%95%9C-%EC%A1%B0%EA%B1%B4%EC%9D%80-%EB%8B%A4%EC%9D%8C-%EC%84%B8%EA%B0%80%EC%A7%80%EC%99%80-%EA%B0%99%EB%8B%A4","aria-label":"critical section 문제를 해결하기 위해 필요한 조건은 다음 세가지와 같다 permalink",className:"header-links before"},a.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"critical section 문제를 해결하기 위해 필요한 조건은 다음 세가지와 같다:"),"\n",a.createElement(n.ol,null,"\n",a.createElement(n.li,null,"Mutual Exclusion (상호 배제)","\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,"한번에 하나의 프로세스/스레드만 critical section을 실행할 수 있다."),"\n"),"\n"),"\n",a.createElement(n.li,null,"Progress (진행)","\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,"만약 critical section이 비어있고, 어떤 프로세스/스레드가 이에 진입하고자 한다면 그렇게 할 수있어야 한다."),"\n"),"\n"),"\n",a.createElement(n.li,null,"Bounded waiting (한정된 대기)","\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,"어떤 프로세스/스레드가 계속 critical section에 들어가지 못하고 대기해서는 안된다."),"\n"),"\n"),"\n"),"\n",a.createElement(n.h4,{id:"critical-section-문제를-해결할-솔루션-3가지를-알아보자-feat-동기화-3대장",style:{position:"relative"}},a.createElement(n.a,{href:"#critical-section-%EB%AC%B8%EC%A0%9C%EB%A5%BC-%ED%95%B4%EA%B2%B0%ED%95%A0-%EC%86%94%EB%A3%A8%EC%85%98-3%EA%B0%80%EC%A7%80%EB%A5%BC-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90-feat-%EB%8F%99%EA%B8%B0%ED%99%94-3%EB%8C%80%EC%9E%A5","aria-label":"critical section 문제를 해결할 솔루션 3가지를 알아보자 feat 동기화 3대장 permalink",className:"header-links before"},a.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Critical Section 문제를 해결할 솔루션 3가지를 알아보자. (feat. 동기화 3대장)"),"\n",a.createElement(n.p,null,"critical section의 조건 중에서는 Mutual Exclusion을 달성하는게 가장 중요해 보인다. 그렇다면 어떻게 mutual exclusion을 해결할 수 있을까?"),"\n",a.createElement(n.p,null,"답은 ",a.createElement("u",null,"Lock"),"을 이용하는 것이다! 진입할 때 Lock을 획득하고, 탈출할 때 Lock을 반환하는 방식."),"\n",a.createElement(n.h5,{id:"spin-lock이란",style:{position:"relative"}},a.createElement(n.a,{href:"#spin-lock%EC%9D%B4%EB%9E%80","aria-label":"spin lock이란 permalink",className:"header-links before"},a.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Spin Lock이란?"),"\n",a.createElement(n.p,null,"loop을 이용해 계속 Lock의 여부를 확인하는 방식을 Spin lock이라고 한다."),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-java"},"volatile int lock = 0;\n\nvoid critical() {\n  // lock을 얻어야만 탈출할 수 있는 무한 루프 (waiting...) \n  // 계속 while loop을 돌면서 test_and_set을 확인하므로 이를 busy waiting이라고 한다.\n  while (test_and_set(&lock) == 1);\n  // ... critical setion 진입\n  lock = 0;\n}\n")),"\n",a.createElement(n.blockquote,null,"\n",a.createElement(n.p,null,"이 때 ",a.createElement(n.code,null,"test_and_set")," 명령어는 atomic한 명령어다. CPU 레벨에서 동기화를 해준다."),"\n"),"\n",a.createElement(n.p,null,"Lock을 가질 수 있을 때까지 busy waiting을 하므로 CPU를 낭비하게 된다. 확인 연산 역시 CPU 위에서 실행되니까 어찌보면 동기화를 획득하기 위해 application과 무관한 오버헤드가 유저 코드 레벨에서 발생한다고 볼 수 있다."),"\n",a.createElement(n.h5,{id:"mutex란",style:{position:"relative"}},a.createElement(n.a,{href:"#mutex%EB%9E%80","aria-label":"mutex란 permalink",className:"header-links before"},a.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Mutex란?"),"\n",a.createElement(n.p,null,"Busy waiting은 너무 비효울적이다··· Lock이 준비될 때까지 thread가 잠자고 있다가 준비되면 일어나서 진입하면 되지 않을까?"),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-java"},"class Mutex {\n  int value = 0;\n \tint guard = 0;\n}\n\nMutex::lock() {\n  while (test_and_set(&guard));\n  if (value == 0) {\n    // 현재 thread를 큐에 넣는다.\n    guard = 0; & go to sleep \n  } else {\n    value = 0;\n    guard = 0;\n  }\n}\n\nMutex::unlock() {\n  while (test_and_set(&guard));\n  if (큐에 하나라도 대기중이라면) {\n    그 중에 하나를 깨운다\n  } else {\n    value = 1;\n  }\n  guard = 0;\n}\n\n\nmutex -> lock();\n... critical section \nmutex -> unlock();\n")),"\n",a.createElement(n.h5,{id:"항상-spin-lock보다-mutex가-효율적인가요",style:{position:"relative"}},a.createElement(n.a,{href:"#%ED%95%AD%EC%83%81-spin-lock%EB%B3%B4%EB%8B%A4-mutex%EA%B0%80-%ED%9A%A8%EC%9C%A8%EC%A0%81%EC%9D%B8%EA%B0%80%EC%9A%94","aria-label":"항상 spin lock보다 mutex가 효율적인가요 permalink",className:"header-links before"},a.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"항상 Spin Lock보다 Mutex가 효율적인가요?"),"\n",a.createElement(n.p,null,"Nope. 대신 2가지 조건이 있다."),"\n",a.createElement(n.ol,null,"\n",a.createElement(n.li,null,"\n",a.createElement(n.p,null,"코어의 개수와 thread의 개수가 동일한 멀티 코어 환경이어야 한다."),"\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,"spin lock은 즉시 lock을 획득할 수 있다."),"\n",a.createElement(n.li,null,"싱글 코어일 경우 어차피 lock을 내려놓기 위해 thread를 전환해야하므로 CS가 불가피하다."),"\n"),"\n"),"\n",a.createElement(n.li,null,"\n",a.createElement(n.p,null,"critical section 안에서의 작업이 context switching보다 빨리 끝나는 가벼운 작업이라면"),"\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,"\n",a.createElement(n.p,null,"context switching이 무거운 작업이 되므로··· 최소화 해야겠지?"),"\n"),"\n",a.createElement(n.li,null,"\n",a.createElement(n.p,null,"잠들고 깨는 과정에서 불가피하게 context switching이 발생하므로 차라리 얼마 대기하지도 않을거 spin lock을 돌리는게 낫다. 어차피 spin lock 획득하느라 기다리는거보다 context switching이 더 오래걸릴 경우!"),"\n"),"\n"),"\n"),"\n"),"\n",a.createElement(n.h5,{id:"semaphore",style:{position:"relative"}},a.createElement(n.a,{href:"#semaphore","aria-label":"semaphore permalink",className:"header-links before"},a.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Semaphore"),"\n",a.createElement(n.p,null,"시그널 메커니즘을 가진 하나 이상의 프로세스/스레드가 critical section에 접근 가능하도록 하는 장치"),"\n",a.createElement(n.p,null,"Binary Semaphore는 사실상 Mutex와 동일하다고 볼 수 있는줄 알았는데 아니다."),"\n",a.createElement(n.p,null,"세마포는 순서를 정해줄 때도 사용할 수 있다."),"\n",a.createElement(n.h5,{id:"mutex와-binary-semaphore는-똑같은-것-아닌가",style:{position:"relative"}},a.createElement(n.a,{href:"#mutex%EC%99%80-binary-semaphore%EB%8A%94-%EB%98%91%EA%B0%99%EC%9D%80-%EA%B2%83-%EC%95%84%EB%8B%8C%EA%B0%80","aria-label":"mutex와 binary semaphore는 똑같은 것 아닌가 permalink",className:"header-links before"},a.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Mutex와 Binary Semaphore는 똑같은 것 아닌가?"),"\n",a.createElement(n.p,null,"Nope. 다르다."),"\n",a.createElement(n.p,null,"Mutex는 Lock을 가진 자만 Lock을 해제할 수 있다. 하지만 Semaphore는 그렇지 않다. wait를 하는 존재와 signal을 날리는 존재가 다를 수 있다."),"\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,"물론 wait를 건 thread들 중 하나가 signal을 날리긴한다. 하지만 마지막에 wait으로 임계영역을 lock-in한 thread가 lock을 푼다고 보장할 수는 없다."),"\n"),"\n",a.createElement(n.p,null,"Mutex의 경우 누가 lock을 해제할지 예측할 수 있다. Lock을 가진 thread가 해제할 테니까!"),"\n",a.createElement(n.p,null,"Mutex는 priority inheritance 속성을 가진다. Semaphore는 그 속성이 없다."),"\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,"여러 process나 thread가 동시에 실행을 하게되면 CPU에 누구를 올릴지 스케줄링을 하게 되는데, 이 때 kernel은 우선순위를 고려한다."),"\n"),"\n",a.createElement(n.p,null,"상호 배제만 필요하다면 Mutex를, 작업 간의 실행 순서 동기가 필요하다면 Semaphore를 권장한다."),"\n",a.createElement(n.p,null,"S의 값이 2 이상인 세마포어를 카운팅 세마포어라고 한다. 이 때 S의 값은 접근할 수 있는 공유자원의 수보다 작거나 같아야 한다. 크다면 race condition을 또다시 경험할 것이다···"),"\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,"Array로 된 공유자원에 접근할 수 있게 한다고 보면 되겠다."),"\n"),"\n",a.createElement(n.h2,{id:"모니터란",style:{position:"relative"}},a.createElement(n.a,{href:"#%EB%AA%A8%EB%8B%88%ED%84%B0%EB%9E%80","aria-label":"모니터란 permalink",className:"header-links before"},a.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"모니터란?"),"\n",a.createElement(n.h4,{id:"모니터란-1",style:{position:"relative"}},a.createElement(n.a,{href:"#%EB%AA%A8%EB%8B%88%ED%84%B0%EB%9E%80-1","aria-label":"모니터란 1 permalink",className:"header-links before"},a.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"모니터란?"),"\n",a.createElement(n.p,null,"모니터는 Mutex와 Condition variable로 이루어져 있다."),"\n",a.createElement(n.p,null,"Mutex"),"\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,"Mutex Lock을 취득하지 못한 thread는 큐에 들어간 후 waiting 상태로 전환한다."),"\n",a.createElement(n.li,null,"Mutex Lock을 쥔 thread가 lock을 반환하며 큐의 thread 중 하나를 깨우며 그 thread가 critical section에 들어가게 된다."),"\n"),"\n",a.createElement(n.p,null,"Condition Variable"),"\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,"기본적으로 waiting queue를 가진다: 조건이 충족되길 기다리는 thread들이 대기 상태로 머무는 곳"),"\n"),"\n",a.createElement(n.p,null,"Condition Variable의 주요 동작은 다음과 같다:"),"\n",a.createElement(n.ol,null,"\n",a.createElement(n.li,null,"wait","\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,"thread가 자기 자신을 condition variable의 waiting queue에 넣고 대기 상태로 전환한다."),"\n",a.createElement(n.li,null,"예를들어, 본인이 기대한 조건이 충족되지 않았을 때 wait를 거는 것"),"\n"),"\n"),"\n",a.createElement(n.li,null,"signal","\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,"waiting queue에서 대기중인 thread 중 하나 깨운다"),"\n"),"\n"),"\n",a.createElement(n.li,null,"broadcast","\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,"waiting queue에서 대기중인 thread를 전부 깨운다."),"\n"),"\n"),"\n"),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-java"},"acquire(m);\t// Lock 취득 (Mutex와 관련) > 이후부터 critical section\n\nwhile (!p) {\t// 조건을 확인하고\n \twait(m, cv);\t// 조건이 충족되지 않는다면 Condition Variable이 관리하는 Waiting Queue에 들어가서 waiting 상태로 들어간다. (condition variable을 같이 준다.)\n}\n\n// Critical Section 작업들...\n\nsignal(cv2); 혹은 broadcast(cv2);\t// cv2가 cv와 같을 수도 있다. (상황에 따라 다르다.)\nrelease(m); // Lock 반환\n")),"\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,"Mutex와 관련된 대기 큐를 entry queue라고 부른다. (이전의 Mutex 락과 동일)","\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,"Condition Variable이 관리하는 Waiting Queue와는 다른 것이다."),"\n"),"\n"),"\n",a.createElement(n.li,null,a.createElement(n.code,null,"wait(m, cv)"),"에 mutex lock도 같이 전달하는 이유는?","\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,"해당 thread도 이제 wating 상태로 들어갈건데 lock을 쥐고 있으면 안된다! 다른 thread들이 블록되므로."),"\n",a.createElement(n.li,null,"따라서 ",a.createElement(n.code,null,"wait"),"을 실행할 때는 mutex lock을 반환했다가, 특정 condition이 되어서 깨어날 때가 되면 다시 lock을 얻어야 겠지?"),"\n"),"\n"),"\n"),"\n",a.createElement(n.p,null,"모니터에는 두 개의 Queue가 존재한다."),"\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,"Entry Queue: critical section에 진입을 기다리는 Queue. Mutex에 의해 관리된다."),"\n",a.createElement(n.li,null,"Waiting Queue: 조건이 충족되길 기다리는 Queue. Condition Variable이 관리한다."),"\n"),"\n",a.createElement(n.h5,{id:"bounded-producerconsumer-문제는-무엇인가요",style:{position:"relative"}},a.createElement(n.a,{href:"#bounded-producerconsumer-%EB%AC%B8%EC%A0%9C%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94","aria-label":"bounded producerconsumer 문제는 무엇인가요 permalink",className:"header-links before"},a.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Bounded producer/consumer 문제는 무엇인가요?"),"\n",a.createElement(n.p,null,"Producer와 Consumer는 buffer를 사이에 두고 통신한다고 가정하자. Buffer 사이즈가 한정되어있기 때문에 발생하는 문제이다."),"\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,"Producer 입장에서는 버퍼가 꽉 차있을 경우 버퍼를 그만 채워주어야 하고"),"\n",a.createElement(n.li,null,"Consumer 입장에서는 버퍼가 비어있을 경우 잠시 대기해야한다."),"\n"),"\n",a.createElement(n.p,null,"이  bounded producer/consumer 문제를 Monitor를 이용해 해결할 수 있다."),"\n",a.createElement(n.p,null,"![image-20231024232143467](/Users/leobang/Library/Application Support/typora-user-images/image-20231024232143467.png)"),"\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,a.createElement(n.code,null,"wait()"),"는 반드시 조건을 확인하는 while loop 안에서 실행되어야 한다."),"\n",a.createElement(n.li,null,"왜냐하면 thread가 waiting queue에서 나오는 순간은 당연히 조건이 만족되는 순간이겠지만, entry queue에서 나오는, mutex lock을 획득하는 순간은 조건과는 무관할 수 있기 때문이다."),"\n",a.createElement(n.li,null,"entry queue에서 다음 thread를 깨우는 로직에 따라 영원한 잠에 들 수도 있다···"),"\n"),"\n",a.createElement(n.h2,{id:"데드락이란",style:{position:"relative"}},a.createElement(n.a,{href:"#%EB%8D%B0%EB%93%9C%EB%9D%BD%EC%9D%B4%EB%9E%80","aria-label":"데드락이란 permalink",className:"header-links before"},a.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"데드락이란?"),"\n",a.createElement(n.blockquote,null,"\n",a.createElement(n.p,null,"2개 이상의 프로세스/스레드가 서로가 가진 리소스를 기다리는 상태"),"\n"),"\n",a.createElement(n.h5,{id:"데드락을-만드는-네가지-조건-이-조건들을-모두-만족시켜야-한다",style:{position:"relative"}},a.createElement(n.a,{href:"#%EB%8D%B0%EB%93%9C%EB%9D%BD%EC%9D%84-%EB%A7%8C%EB%93%9C%EB%8A%94-%EB%84%A4%EA%B0%80%EC%A7%80-%EC%A1%B0%EA%B1%B4-%EC%9D%B4-%EC%A1%B0%EA%B1%B4%EB%93%A4%EC%9D%84-%EB%AA%A8%EB%91%90-%EB%A7%8C%EC%A1%B1%EC%8B%9C%EC%BC%9C%EC%95%BC-%ED%95%9C%EB%8B%A4","aria-label":"데드락을 만드는 네가지 조건 이 조건들을 모두 만족시켜야 한다 permalink",className:"header-links before"},a.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"데드락을 만드는 네가지 조건 (이 조건들을 모두 만족시켜야 한다.)"),"\n",a.createElement(n.ol,null,"\n",a.createElement(n.li,null,"\n",a.createElement(n.p,null,"Mutual Exclusion"),"\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,"리소스를 공유해서 사용할 수 없다. 리소스란 Critical section, Lock과 같은 자원으로 볼 수도 있고, CPU나 각종 디바이스를 가리키는 것 일 수도 있다."),"\n"),"\n"),"\n",a.createElement(n.li,null,"\n",a.createElement(n.p,null,"Hold and Wait"),"\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,"프로세스가 이미 하나 이상의 리소스를 취득(hold)한 상태에서 다른 프로세스가 사용하고 있는 리소스를 추가적으로 기다린다(wait). 즉, 가지고 있는 상황에서 또 다른 거를 기다리는 상태."),"\n"),"\n"),"\n",a.createElement(n.li,null,"\n",a.createElement(n.p,null,"No Preemption"),"\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,"리소스 반환은 오직 그 리소스를 취득한 프로세스만 할 수 있다. preemption, 즉, 작업이 끝나지 않은 상태에서 리소스를 떠날 일은 없다는 것."),"\n"),"\n"),"\n",a.createElement(n.li,null,"\n",a.createElement(n.p,null,"Circular wait"),"\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,"프로세스들이 순환하는 형태로 서로의 리소스를 기다리고 있는 상황."),"\n"),"\n"),"\n"),"\n",a.createElement(n.h5,{id:"os-레벨에서-데드락은-어떻게-해결할까",style:{position:"relative"}},a.createElement(n.a,{href:"#os-%EB%A0%88%EB%B2%A8%EC%97%90%EC%84%9C-%EB%8D%B0%EB%93%9C%EB%9D%BD%EC%9D%80-%EC%96%B4%EB%96%BB%EA%B2%8C-%ED%95%B4%EA%B2%B0%ED%95%A0%EA%B9%8C","aria-label":"os 레벨에서 데드락은 어떻게 해결할까 permalink",className:"header-links before"},a.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"OS 레벨에서 데드락은 어떻게 해결할까?"),"\n",a.createElement(n.p,null,"데드락을 아예 예방하는 방식 (위 네가지 조건 중 하나를 사전에 방지)은 자원낭비가 매우 심하다. 따라서 데드락을 회피하거나, 발생하게 허용한 후 탐지하여 해결하도록 한다. 혹은 개발자가 알아서 해결하라고 하고 OS레벨에서는 ‘아몰랑’을 시전하는 경우도 많다."),"\n",a.createElement(n.p,null,"데드락 회피 방식에는 Banker Algorithm이 있다."),"\n",a.createElement(n.blockquote,null,"\n",a.createElement(n.p,null,"리소스 요청을 허락해줬을 때 데드락이 발생할 가능성이 있다면 리소스를 할당해도 안전할 때까지 계속 요청을 거절하는 알고리즘."),"\n"),"\n",a.createElement(n.h5,{id:"프로그래밍-레벨에서-보는-데드락",style:{position:"relative"}},a.createElement(n.a,{href:"#%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%A0%88%EB%B2%A8%EC%97%90%EC%84%9C-%EB%B3%B4%EB%8A%94-%EB%8D%B0%EB%93%9C%EB%9D%BD","aria-label":"프로그래밍 레벨에서 보는 데드락 permalink",className:"header-links before"},a.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"프로그래밍 레벨에서 보는 데드락"),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-java"},'public class Main {\n  public static void main(String[] args) {\n    // 이 둘은 Mutex Lock이다.\n    Object lock1 = new Object();\n    Object lock2 = new Object();\n    \n    Thread t1 = new Thread(() => {\n      synchronized(lock1) {\n        Sysout("[t1] get lock1");\n        synchronized(lock2) {\n          Sysout("[t1] get lock2 ")\n        }\n      }\n    });\n    \n    Thread t2 = new Thread(() => {\n      synchronized(lock2) {\n        Sysout("[t2] get lock2");\n        synchronized(lock1) {\n          Sysout("[t2] get lock1")\n        }\n      }\n    });\n      \n    t1.start();\n    t2.start();\n  }\n}\n')),"\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,"t1은 lock1을 취득하고 t2가 가진 lock2를 기다리며 waiting 상태에 빠지고,"),"\n",a.createElement(n.li,null,"t2는 lock2를 취득하고 t1이 가진 lock1을 기다리며 waiting 상태에 빠질 수 있다."),"\n"),"\n",a.createElement(n.p,null,"이를 해결하기 위해서는 Mutual Exclusion이 과연 정말 필요한 상황인지 잘 고민해보아야 하며, Mutex의 순서를 잘 고려해야한다. + 반드시 중첩된 lock이 필요할까 (hold and wait)"))}var r=function(e={}){const{wrapper:n}=Object.assign({},(0,t.ah)(),e.components);return n?a.createElement(n,e,a.createElement(c,e)):c(e)},i=l(5670),u=l(1326),o=l(4517),E=l(698),m=l(8627),s=l(662),h=l(1873);const d=({data:e,children:n,serverData:l})=>{const{prevPost:t,nextPost:c}=e,r={...e.mdx.frontmatter,timeToRead:e.mdx.fields.timeToRead};return a.createElement(E.Z,{data:e},a.createElement(i.Z,null,a.createElement(o.Z,r),a.createElement(u.Z,null,n),a.createElement(s.Z,{prev:t,next:c}),a.createElement(m.Z)))};function p(e){return a.createElement(d,e,a.createElement(r,e))}}}]);
//# sourceMappingURL=component---src-templates-article-page-jsx-content-file-path-home-runner-work-leobang-17-github-io-leobang-17-github-io-documents-운영체제-동기화솔루션-md-e935c101537c18a2251e.js.map