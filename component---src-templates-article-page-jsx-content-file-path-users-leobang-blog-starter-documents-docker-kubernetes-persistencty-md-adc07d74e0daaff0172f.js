"use strict";(self.webpackChunkgatsby_theme_simplex=self.webpackChunkgatsby_theme_simplex||[]).push([[2318],{3984:function(e,t,n){n.r(t),n.d(t,{Head:function(){return d.py},default:function(){return P}});var l=n(1151),a=n(7294);function r(e){const t=Object.assign({p:"p",ul:"ul",li:"li",h2:"h2",a:"a",div:"div",strong:"strong",ol:"ol",pre:"pre",code:"code",blockquote:"blockquote",em:"em"},(0,l.ah)(),e.components);return a.createElement(a.Fragment,null,a.createElement(t.p,null,"Docker를 사용할 때는 container 내부의 스토리지를 Host의 스토리지와 마운트해서 데이터의 영속성을 확보했다."),"\n",a.createElement(t.ul,null,"\n",a.createElement(t.li,null,"volume mount를 이용해 docker engine이 관리하는 공간을 mount하거나,"),"\n",a.createElement(t.li,null,"bind mount를 이용해 Host의 스토리지를 직접 mount 했었다."),"\n"),"\n",a.createElement(t.p,null,"하지만 kubernetes를 사용하면서 스토리지의 영속성 문제는 더욱 복잡해졌다. 여러 워커 노드 중 하나에서 실행되다가 어떠한 이유로 종료되고 다른 노드에서 실행되는 경우엔? docker의 해결책만으로는 노드에 걸친 영속성을 확보할 수 없다."),"\n",a.createElement(t.h2,{id:"pod에-임시-스토리지-확보하기-emptydir",style:{position:"relative"}},a.createElement(t.a,{href:"#pod%EC%97%90-%EC%9E%84%EC%8B%9C-%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80-%ED%99%95%EB%B3%B4%ED%95%98%EA%B8%B0-emptydir","aria-label":"pod에 임시 스토리지 확보하기 emptydir permalink",className:"header-links before"},a.createElement(t.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Pod에 임시 스토리지 확보하기: emptyDir"),"\n",a.createElement(t.p,null,"상황에 따라서 어떤 파일들은 Pod의 생명주기와 함께 유지되어도 괜찮을 때가 있다. emptyDir은 ",a.createElement(t.strong,null,"Pod가 실행되는 동안 임시 데이터를 저장하기 위한 볼륨 타입")," 중 하나이다. emptyDir 볼륨은 Pod와 라이프사이클을 같이 한다:"),"\n",a.createElement(t.ol,null,"\n",a.createElement(t.li,null,"Pod가 노드에서 시작할 때 emptyDir이 생성된다."),"\n",a.createElement(t.li,null,"Pod가 종료되면 emptyDir도 사제된다"),"\n"),"\n",a.createElement(t.p,null,"다음과 같이 Pod의 명세에 함께 정의하면 된다:"),"\n",a.createElement(t.pre,null,a.createElement(t.code,{className:"language-yaml"},"apiVersion: v1\nkind: Pod\nmetadata:\n\tname: my-pod\nspec:\n\tvolumes:\n\t- name: temp-volume\n\t\temptryDir: {}\n  containers:\n  - name: first-container\n  \timage: my-app:1.0.0\n  \tvolumeMounts:\n  \t- mountPath: /temp\n  \t\tname: temp-volume\n  - name:\tsecond-container\n  \timage: another-app:1.0.0\n  \tvolumeMounts:\n  \t- mountPath: /storage/files\n  \t\tname: temp-volume\n")),"\n",a.createElement(t.p,null,"emptyDir 볼륨은 물리적으로 Pod가 배치되어있는 워커 노드의 일부를 활용한다. 하지만 Pod에 걸쳐서 emptyDir 볼륨을 공유하지는 못하며, 당연히 더 큰 범위인 노드에 걸쳐서 공유하지도 못한다. 따라서 deployment 등을 사용해서 여러 Pod를 동시에 운용하는 경우에는 사용에 주의해야한다."),"\n",a.createElement(t.p,null,"일반적으로 다음과 같은 경우에 사용한다:"),"\n",a.createElement(t.ul,null,"\n",a.createElement(t.li,null,"일시적인 데이터 저장소 (임시 파일을 다운로드한다거나)"),"\n",a.createElement(t.li,null,"캐싱"),"\n",a.createElement(t.li,null,"로그 파일 저장 (로그 수집 container와 공유)"),"\n",a.createElement(t.li,null,"임시 작업 디렉토리"),"\n"),"\n",a.createElement(t.blockquote,null,"\n",a.createElement(t.p,null,a.createElement(t.strong,null,"emptyDir볼륨을 메모리 기반 스토리지로 설정할 수 있다")),"\n",a.createElement(t.p,null,a.createElement(t.code,null,"medium: Memory")," 옵션을 선택하면 emptyDir 볼륨을 메모리 기반으로 활용할 수 있다. 인메모리 스토리지를 활용하므로 빠른 I/O 속도를 보장받지만, 그만큼 메모리 공간의 관리에 신경써주지 않으면 OOM 이슈를 맞이할 것이다···"),"\n"),"\n",a.createElement(t.h2,{id:"노드의-저장공간을-pod에서-활용하기-hostvolume",style:{position:"relative"}},a.createElement(t.a,{href:"#%EB%85%B8%EB%93%9C%EC%9D%98-%EC%A0%80%EC%9E%A5%EA%B3%B5%EA%B0%84%EC%9D%84-pod%EC%97%90%EC%84%9C-%ED%99%9C%EC%9A%A9%ED%95%98%EA%B8%B0-hostvolume","aria-label":"노드의 저장공간을 pod에서 활용하기 hostvolume permalink",className:"header-links before"},a.createElement(t.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"노드의 저장공간을 Pod에서 활용하기: hostVolume"),"\n",a.createElement(t.p,null,"docker의 bind mount와 비슷한 메커니즘. 워커노드의 특정 디렉토리를 명시하여 이를 container의 디렉토리와 바인딩하며, 이는 양방향으로 동작하기에 호스트(워커노드)의 디렉토리 관리에 주의해야한다."),"\n",a.createElement(t.h2,{id:"persistent-volume-활용하기",style:{position:"relative"}},a.createElement(t.a,{href:"#persistent-volume-%ED%99%9C%EC%9A%A9%ED%95%98%EA%B8%B0","aria-label":"persistent volume 활용하기 permalink",className:"header-links before"},a.createElement(t.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Persistent Volume 활용하기"),"\n",a.createElement(t.p,null,"Persistent Volume은 Pod가 필요한 Volume을 요청하여 사용할 수 있도록 ",a.createElement(t.strong,null,"cluster 레벨에서 제공하는 스토리지"),"이다. 따라서, Pod에 걸친 그리고 여러 노드에 걸쳐서도 데이터 영속성을 보장할 수 있는 방식이다."),"\n",a.createElement(t.p,null,"cluster에는 다양한 타입의 storage가 연결될 수 있다. 네트워크로 연결된 NFS 드라이브가 연결될 수도 있으며, CSP에서 제공하는 블록 스토리지가 연결될 수도 있다."),"\n",a.createElement(t.p,null,"Persistent Volume의 활용 메커니즘은 단순하다. 우선, 관리자는 cluster 레벨에서 공유될 저장공간인 Persistent Volume을 정의해야한다. 다음과 같다:"),"\n",a.createElement(t.pre,null,a.createElement(t.code,{className:"language-yaml"},"apiVersion: v1\nkind: PersistentVolume\nmetadata:\n\tname: my-pv001\nspec:\n\tcapacity: \n\t\tstorage: 10Gi\n  storageClassName: my-storage\n  volumeMode: Filesystem\n  accessModes:\n  - ReadWriteOnce\n  persistentVolumeReclaimPolicy: Delete\n  hostPath:\n  \tpath: /pv-test/pv001\n")),"\n",a.createElement(t.ul,null,"\n",a.createElement(t.li,null,"\n",a.createElement(t.p,null,"10GB의 persistent volume을 정의한다."),"\n"),"\n",a.createElement(t.li,null,"\n",a.createElement(t.p,null,a.createElement(t.code,null,"volumeMode")," 를 통해 해당 volume이 Pod 속 container에 마운트될 때 container의 file system의 일부로 인식되도록 정의한다. 즉, container 내부의 디렉토리로 인식한다는 말이다."),"\n"),"\n",a.createElement(t.li,null,"\n",a.createElement(t.p,null,a.createElement(t.code,null,"accessMode"),"를 통해 다수의 노드에서 접근하는 전략을 설정할 수 있다."),"\n"),"\n",a.createElement(t.li,null,"\n",a.createElement(t.p,null,a.createElement(t.code,null,"persistentVolumeReclaimPolicy"),"를 통해 PV의 사용이 끝났을 때 해당 볼륨에 저장된 파일을 어떻게 처리할 것인지에 대한 정책을 정의한다."),"\n"),"\n"),"\n",a.createElement(t.blockquote,null,"\n",a.createElement(t.p,null,"Persistent Volume은 정적으로 제공되는 공간이기에 Pod가 생성되기 이전에 미리 준비되어야 한다."),"\n"),"\n",a.createElement(t.p,null,"이제 Persistent Volume을 cluster 레벨에서 정의했으니, cluster 내의 Pod가 해당 스토리지를 활용할 수 있도록 연결해야한다. 이 때 스토리지를 원하는 Pod는 Persistent Volume Claim 오브젝트를 선언해서 kubernetes에게 ‘명세에 맞는 Persistent Volume 중 적당한 것을 달라’ 고 요청해야한다."),"\n",a.createElement(t.p,null,"이 때, Persistent Volume의 특성에 대해 다시 생각해보자. PV는 kubernetes cluster 전체에 제공되는 ",a.createElement(t.strong,null,"추상화된 저장공간"),"이다. 따라서 Pod가 PV를 마운트하기 위해서는 ",a.createElement(t.code,null,"my-pv001"),"이라는 PV를 직접 지정하는 것이 아니라, Pod에 필요한 저장공간의 추상화된 속성을 열거하여 요청하는 것이다."),"\n",a.createElement(t.pre,null,a.createElement(t.code,{className:"language-yaml"},"apiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n\tname: my-pv-claim-01\nspec:\n\tstorageClassName: my-storage\n\taccessModes:\n\t- ReadWriteOnce\n\tresources:\n\t\trequests:\n\t\t\tstorage: 5Gi\n")),"\n",a.createElement(t.ul,null,"\n",a.createElement(t.li,null,"5GiB 이상의 저장공간을 가지고 있으며, 하나의 노드에서만 읽고 쓸 수 있고 스토리지 클래스가 ",a.createElement(t.code,null,"my-storage"),"인 조건을 만족하는 Persistent Volume 중 적당한 것을 할당해줘"),"\n"),"\n",a.createElement(t.p,null,"PVC는 kubernetes가 가장 적합한 PV를 찾아서 알아서 할당해준다. 이 때, ",a.createElement(t.strong,null,"PV와 PVC의 관계는 one-to-one")," 이다. 즉, Persistent Volume Claim에 바운드된 Persistent Volume은 다른 Persistent Volume Claim에 동시에 바운드될 수 없다."),"\n",a.createElement(t.p,null,"위의 예시를 보면, 10GiB의 PV가 있고 그 중에 5GiB 만큼의 PVC를 요청했다. ‘PV의 유휴 공간인 5GiB만큼 더 요청하는 PVC를 정의해도 되겠군’ 이라고 생각할 수 있지만, PVC와 PV는 1대1 매핑이므로 현재 가용 PV가 존재하지 않아 새로운 PVC 요청은 ",a.createElement(t.code,null,"pending")," 상태에 머무르며 새로운 적당한 PV가 나타나기를 기다리게 된다."),"\n",a.createElement(t.p,null,"아무튼 이제 PVC도 매핑되었으니, PVC로 요청한 스토리지를 실제 Pod에 마운트해주어야 한다."),"\n",a.createElement(t.pre,null,a.createElement(t.code,{className:"language-yaml"},"apiVersion: v1\nkind: Pod\nmetadata: \n\tname: my-pod\nspec:\n\tcontainers:\n\t\t- name: my-container\n\t\t\timage: my-app:1.0.0\n\t\t\tvolumeMounts:\n\t\t\t\t- name: my-pvc\n\t\t\t\t\tpersistentVolumeClaim:\n\t\t\t\t\t\tclaimName: my-pv-claim-01\n")),"\n",a.createElement(t.p,null,"Persistent Volume을 이용해서 Pod간, 노드간 데이터 영속성을 달성할 수 있었지만 PV는 특성상 정적으로 제공되는 저장공간이므로 불편한 점이 많다. PVC로 요청할 때 필요한 용량 보다 더 큰 용량을 가진 PV가 매핑될 수도 있으며, 모든 PV가 할당된 경우에는 PVC의 요청에도 계속 대기하고 있을 수 있다."),"\n",a.createElement(t.h2,{id:"storage-class로-동적할당하기",style:{position:"relative"}},a.createElement(t.a,{href:"#storage-class%EB%A1%9C-%EB%8F%99%EC%A0%81%ED%95%A0%EB%8B%B9%ED%95%98%EA%B8%B0","aria-label":"storage class로 동적할당하기 permalink",className:"header-links before"},a.createElement(t.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Storage Class로 동적할당하기"),"\n",a.createElement(t.p,null,"스토리지를 동적으로 할당할 수 있다면 Pod의 볼륨에 대한 수요를 유연하게 처리할 수 있을 것이다. 스토리지가 필요한 시점에 필요한 만큼의 스토리지를 생성한 후, Pod에 할당하는 방식이다. Storage Class는 동적 프로비저닝을 위한 설정으로, 동적으로 스토리지를 할당하는 서비스를 제공하는 CSP의 솔루션을 연결해서 제공하는 방식이다."),"\n",a.createElement(t.blockquote,null,"\n",a.createElement(t.p,null,"kubernetes에서 ",a.createElement(t.em,null,"영속성을 달성하기 위해 가장 많이 사용하는 방식은 Storage Class"),"이다."),"\n"),"\n",a.createElement(t.p,null,"StorageClass는 PV와 마찬가지로 사전에 정의되어있어야 한다. 하지만 PV와는 다르게 할당할 저장공간을 정의할 필요가 없으며 (동적으로 확장되므로) Storage Class는 PVC와 one-to-many 관계를 맺는다."),"\n",a.createElement(t.p,null,"동적 프로비저닝이 가능한 대표적인 스토리지 서비스인 AWS의 EBS (Elastic Block Storage)를 예시로 정의해보자:"),"\n",a.createElement(t.pre,null,a.createElement(t.code,{className:"language-yaml"},"apiVersion: storage.k8s.io/v1\nkind: StorageClass\nmetadata:\n\tname: ebs-storage\nprovisioner: kubernetes.io/aws-ebs\nparameters:\n\ttype: gp2\nreclaimPolicy: Retain\nallowVolumeExpansion: true\nvolumeBindingMode: Immediate\n")),"\n",a.createElement(t.ul,null,"\n",a.createElement(t.li,null,"볼륨을 동적으로 확장할 수 있는 EBS 공간을 확보했다. (이미 생성된 볼륨을 축소하는 것은 허용되지 않는다)"),"\n",a.createElement(t.li,null,"이 StorageClass를 사용하는 PVC가 생성되면 바로 저장소를 생성해서 할당한다."),"\n"),"\n",a.createElement(t.p,null,"PV와 같이 해당 StorageClass도 사용하고자 할당을 요청하는 PVC를 정의해야한다."),"\n",a.createElement(t.pre,null,a.createElement(t.code,{className:"language-yaml"},"apiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n\tname: ebs-claim\nspec:\n\taccessModes:\n\t\t- ReadWriteOnce\n  storageClassName: ebs-storage\n  resources:\n  \trequests:\n  \t\tstorage: 10Gi\n")),"\n",a.createElement(t.p,null,"PVC에 원하는 저장공간이 할당되었다면, 해당 PVC를 Pod에 마운트하도록 정의해야한다. 방식은 PV 챕터에서 다룬 것과 동일하다."))}var m=function(e={}){const{wrapper:t}=Object.assign({},(0,l.ah)(),e.components);return t?a.createElement(t,e,a.createElement(r,e)):r(e)},o=n(5670),s=n(1326),c=n(4517),i=n(698),u=n(8627),E=n(662),d=n(1873);const p=({data:e,children:t,serverData:n})=>{const{prevPost:l,nextPost:r}=e,m={...e.mdx.frontmatter,timeToRead:e.mdx.fields.timeToRead};return a.createElement(i.Z,{data:e},a.createElement(o.Z,null,a.createElement(c.Z,m),a.createElement(s.Z,null,t),a.createElement(E.Z,{prev:l,next:r}),a.createElement(u.Z)))};function P(e){return a.createElement(p,e,a.createElement(m,e))}}}]);
//# sourceMappingURL=component---src-templates-article-page-jsx-content-file-path-users-leobang-blog-starter-documents-docker-kubernetes-persistencty-md-adc07d74e0daaff0172f.js.map