"use strict";(self.webpackChunkgatsby_theme_simplex=self.webpackChunkgatsby_theme_simplex||[]).push([[4438],{5107:function(e,n,t){t.r(n),t.d(n,{Head:function(){return E.py},default:function(){return h}});var l=t(1151),a=t(7294);function r(e){const n=Object.assign({p:"p",pre:"pre",code:"code",h2:"h2",a:"a",div:"div",strong:"strong",ul:"ul",li:"li",em:"em",blockquote:"blockquote",ol:"ol"},(0,l.ah)(),e.components);return a.createElement(a.Fragment,null,a.createElement(n.p,null,"Go에서 map은 다른 언어의 Hash Map과 같이 key-value 쌍으로 데이터를 저장하는 자료구조이다. map은 일반적으로 O(1)의 조회, 쓰기 연산을 지원한다."),"\n",a.createElement(n.p,null,"다음과 같이 map을 이용할 수 있다:"),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-go"},'// map declaration & initialize\nm := make(map[string]int)\n\n// map insert\nm["apple"] = 5\nm["banana"] = 3\n\n// delete key\ndelete(m, "apple") // key 삭제 \n\n// check if a key exists\nelem, ok := m["apple"] // ok는 error가 아닌 boolean이다. key가 없을 경우 ok는 false를 반환하고, elem에는 0이 반환된다.\n')),"\n",a.createElement(n.h2,{id:"restriction-in-key-types",style:{position:"relative"}},a.createElement(n.a,{href:"#restriction-in-key-types","aria-label":"restriction in key types permalink",className:"header-links before"},a.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Restriction in Key Types"),"\n",a.createElement(n.p,null,"map의 key와 value는 다양한 type으로 구성할 수 있다. value의 경우 모든 type을 수용할 수 있지만, ",a.createElement(n.strong,null,"key로 사용될 type은 모두 comparable"),"해야한다."),"\n",a.createElement(n.p,null,"in terms of “comparable”, 다음과 같이 구분 지을 수 있다,"),"\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,"comparable","\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,"boolean, numeric, string, pointer, channel, interface, struct, array"),"\n",a.createElement(n.li,null,"struct와 array는 ",a.createElement(n.em,null,"포함하는 field나 element의 type이 모두 comparable할 때에만")," 그 역시 comparable하다."),"\n"),"\n"),"\n",a.createElement(n.li,null,"incomparable","\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,"slices, map, function"),"\n",a.createElement(n.li,null,"이들은 pointer를 비교하는 것이지 각 value를 비교하는 것이 아니다."),"\n"),"\n"),"\n"),"\n",a.createElement(n.blockquote,null,"\n",a.createElement(n.p,null,"array는 comparable하지만, slice는 incomparable하다. array는 길이가 고정되어있기 때문에 비교할 수 있는 것이다."),"\n"),"\n",a.createElement(n.p,null,"struct를 map의 key로 이용하는 예시를 보자. 특정 웹사이트의 endpoint에 접속한 조회수를 기록하고자 하는데, 이 때 국가별로 조회수를 관리하고자 한다. 단순히 생각하자면, map의 map으로 자료를 저장할 수 있겠다."),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-go"},'hits := make(map[string]map[string]int) // endpoint: country : hit_count\n\nhits["/docs/"]["au"] // /docs path의 호주 조회수를 알고 싶다면.\n')),"\n",a.createElement(n.p,null,"이러한 접근법은 직관적이긴 하지만, map을 초기화하고 이용하는데 여러 불편함이 생긴다. 데이터를 추가하고자할 때, 먼저 inner map이 존재하는지 확인하고 outer map을 조작해야하기 때문이다."),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-go"},'func add(m map[string]map[string]int, path, country string) {\n    mm, ok := m[path]\n    if !ok {\n        mm = make(map[string]int)\n        m[path] = mm\n    }\n    mm[country]++\n}\nadd(hits, "/doc/", "au")\n')),"\n",a.createElement(n.p,null,"위와 같은 방식 대신, struct 자료형을 key로 활용함으로서 요구사항을 보다 간단하게 구현할 수 있다."),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-go"},'type Key struct {\n  Path, Country string\n}\nhits := make(map[Key]int)\n\nhits[Key { "/", "au" }]++\nn := hits[Key{ "/ref/spec", "ch" }]\n')),"\n",a.createElement(n.h2,{id:"map을-이용할-때-주의해야할-점",style:{position:"relative"}},a.createElement(n.a,{href:"#map%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%A0-%EB%95%8C-%EC%A3%BC%EC%9D%98%ED%95%B4%EC%95%BC%ED%95%A0-%EC%A0%90","aria-label":"map을 이용할 때 주의해야할 점 permalink",className:"header-links before"},a.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Map을 이용할 때 주의해야할 점"),"\n",a.createElement(n.ol,null,"\n",a.createElement(n.li,null,"\n",a.createElement(n.p,null,"Map의 key-value는 순서를 보장하지 않는다."),"\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,"Map은 iterable한 collection이지만, key-value는 순서를 보장하지 않는다. 따라서 ",a.createElement(n.code,null,"for := range")," 구문을 활용해 map을 iterate할 때 매번 key-value 쌍의 순서가 다를 수 있으므로 이에 유의하여 코드를 작성해야한다."),"\n"),"\n"),"\n",a.createElement(n.li,null,"\n",a.createElement(n.p,null,"Nil Map"),"\n",a.createElement(n.ul,null,"\n",a.createElement(n.li,null,"\n",a.createElement(n.p,null,"initialize되지 않은 Map, 즉, 선언만 하고 ",a.createElement(n.code,null,"nil"),"인 상태의 Map 변수에 접근해 ",a.createElement(n.em,null,"데이터를 쓰려고 하면")," runtime panic이 발생한다. 따라서 map을 이용하기 전에 ",a.createElement(n.code,null,"make")," function을 이용해 초기화해주어야 한다."),"\n"),"\n",a.createElement(n.li,null,"\n",a.createElement(n.p,null,"하지만 ",a.createElement(n.code,null,"nil")," map에서 읽기 시도는 panic을 발생시키지 않고, 단지 ",a.createElement(n.code,null,"zero value"),"를 반환한다."),"\n"),"\n"),"\n"),"\n"))}var c=function(e={}){const{wrapper:n}=Object.assign({},(0,l.ah)(),e.components);return n?a.createElement(n,e,a.createElement(r,e)):r(e)},m=t(5670),i=t(1326),u=t(4517),p=t(698),o=t(8627),s=t(662),E=t(1873);const d=({data:e,children:n,serverData:t})=>{const{prevPost:l,nextPost:r}=e,c={...e.mdx.frontmatter,timeToRead:e.mdx.fields.timeToRead};return a.createElement(p.Z,{data:e},a.createElement(m.Z,null,a.createElement(u.Z,c),a.createElement(i.Z,null,n),a.createElement(s.Z,{prev:l,next:r}),a.createElement(o.Z)))};function h(e){return a.createElement(d,e,a.createElement(c,e))}}}]);
//# sourceMappingURL=component---src-templates-article-page-jsx-content-file-path-home-runner-work-leobang-17-github-io-leobang-17-github-io-documents-go-lang-go-map-md-2217e805f0dbcc6a4123.js.map