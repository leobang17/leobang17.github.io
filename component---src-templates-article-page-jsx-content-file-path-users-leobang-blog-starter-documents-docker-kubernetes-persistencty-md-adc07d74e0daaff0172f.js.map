{"version":3,"file":"component---src-templates-article-page-jsx-content-file-path-users-leobang-blog-starter-documents-docker-kubernetes-persistencty-md-adc07d74e0daaff0172f.js","mappings":"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","sources":["webpack://gatsby-theme-simplex/./documents/Docker/kubernetes-persistencty.md","webpack://gatsby-theme-simplex/./src/templates/ArticlePage.jsx"],"sourcesContent":["/*@jsxRuntime classic @jsx React.createElement @jsxFrag React.Fragment*/\nimport {useMDXComponents as _provideComponents} from \"@mdx-js/react\";\nimport React from \"react\";\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    ul: \"ul\",\n    li: \"li\",\n    h2: \"h2\",\n    a: \"a\",\n    div: \"div\",\n    strong: \"strong\",\n    ol: \"ol\",\n    pre: \"pre\",\n    code: \"code\",\n    blockquote: \"blockquote\",\n    em: \"em\"\n  }, _provideComponents(), props.components);\n  return React.createElement(React.Fragment, null, React.createElement(_components.p, null, \"Docker를 사용할 때는 container 내부의 스토리지를 Host의 스토리지와 마운트해서 데이터의 영속성을 확보했다.\"), \"\\n\", React.createElement(_components.ul, null, \"\\n\", React.createElement(_components.li, null, \"volume mount를 이용해 docker engine이 관리하는 공간을 mount하거나,\"), \"\\n\", React.createElement(_components.li, null, \"bind mount를 이용해 Host의 스토리지를 직접 mount 했었다.\"), \"\\n\"), \"\\n\", React.createElement(_components.p, null, \"하지만 kubernetes를 사용하면서 스토리지의 영속성 문제는 더욱 복잡해졌다. 여러 워커 노드 중 하나에서 실행되다가 어떠한 이유로 종료되고 다른 노드에서 실행되는 경우엔? docker의 해결책만으로는 노드에 걸친 영속성을 확보할 수 없다.\"), \"\\n\", React.createElement(_components.h2, {\n    id: \"pod에-임시-스토리지-확보하기-emptydir\",\n    style: {\n      position: \"relative\"\n    }\n  }, React.createElement(_components.a, {\n    href: \"#pod%EC%97%90-%EC%9E%84%EC%8B%9C-%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80-%ED%99%95%EB%B3%B4%ED%95%98%EA%B8%B0-emptydir\",\n    \"aria-label\": \"pod에 임시 스토리지 확보하기 emptydir permalink\",\n    className: \"header-links before\"\n  }, React.createElement(_components.div, {\n    dangerouslySetInnerHTML: {\n      __html: \"<svg aria-hidden=\\\"true\\\" focusable=\\\"false\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg>\"\n    }\n  })), \"Pod에 임시 스토리지 확보하기: emptyDir\"), \"\\n\", React.createElement(_components.p, null, \"상황에 따라서 어떤 파일들은 Pod의 생명주기와 함께 유지되어도 괜찮을 때가 있다. emptyDir은 \", React.createElement(_components.strong, null, \"Pod가 실행되는 동안 임시 데이터를 저장하기 위한 볼륨 타입\"), \" 중 하나이다. emptyDir 볼륨은 Pod와 라이프사이클을 같이 한다:\"), \"\\n\", React.createElement(_components.ol, null, \"\\n\", React.createElement(_components.li, null, \"Pod가 노드에서 시작할 때 emptyDir이 생성된다.\"), \"\\n\", React.createElement(_components.li, null, \"Pod가 종료되면 emptyDir도 사제된다\"), \"\\n\"), \"\\n\", React.createElement(_components.p, null, \"다음과 같이 Pod의 명세에 함께 정의하면 된다:\"), \"\\n\", React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-yaml\"\n  }, \"apiVersion: v1\\nkind: Pod\\nmetadata:\\n\\tname: my-pod\\nspec:\\n\\tvolumes:\\n\\t- name: temp-volume\\n\\t\\temptryDir: {}\\n  containers:\\n  - name: first-container\\n  \\timage: my-app:1.0.0\\n  \\tvolumeMounts:\\n  \\t- mountPath: /temp\\n  \\t\\tname: temp-volume\\n  - name:\\tsecond-container\\n  \\timage: another-app:1.0.0\\n  \\tvolumeMounts:\\n  \\t- mountPath: /storage/files\\n  \\t\\tname: temp-volume\\n\")), \"\\n\", React.createElement(_components.p, null, \"emptyDir 볼륨은 물리적으로 Pod가 배치되어있는 워커 노드의 일부를 활용한다. 하지만 Pod에 걸쳐서 emptyDir 볼륨을 공유하지는 못하며, 당연히 더 큰 범위인 노드에 걸쳐서 공유하지도 못한다. 따라서 deployment 등을 사용해서 여러 Pod를 동시에 운용하는 경우에는 사용에 주의해야한다.\"), \"\\n\", React.createElement(_components.p, null, \"일반적으로 다음과 같은 경우에 사용한다:\"), \"\\n\", React.createElement(_components.ul, null, \"\\n\", React.createElement(_components.li, null, \"일시적인 데이터 저장소 (임시 파일을 다운로드한다거나)\"), \"\\n\", React.createElement(_components.li, null, \"캐싱\"), \"\\n\", React.createElement(_components.li, null, \"로그 파일 저장 (로그 수집 container와 공유)\"), \"\\n\", React.createElement(_components.li, null, \"임시 작업 디렉토리\"), \"\\n\"), \"\\n\", React.createElement(_components.blockquote, null, \"\\n\", React.createElement(_components.p, null, React.createElement(_components.strong, null, \"emptyDir볼륨을 메모리 기반 스토리지로 설정할 수 있다\")), \"\\n\", React.createElement(_components.p, null, React.createElement(_components.code, null, \"medium: Memory\"), \" 옵션을 선택하면 emptyDir 볼륨을 메모리 기반으로 활용할 수 있다. 인메모리 스토리지를 활용하므로 빠른 I/O 속도를 보장받지만, 그만큼 메모리 공간의 관리에 신경써주지 않으면 OOM 이슈를 맞이할 것이다···\"), \"\\n\"), \"\\n\", React.createElement(_components.h2, {\n    id: \"노드의-저장공간을-pod에서-활용하기-hostvolume\",\n    style: {\n      position: \"relative\"\n    }\n  }, React.createElement(_components.a, {\n    href: \"#%EB%85%B8%EB%93%9C%EC%9D%98-%EC%A0%80%EC%9E%A5%EA%B3%B5%EA%B0%84%EC%9D%84-pod%EC%97%90%EC%84%9C-%ED%99%9C%EC%9A%A9%ED%95%98%EA%B8%B0-hostvolume\",\n    \"aria-label\": \"노드의 저장공간을 pod에서 활용하기 hostvolume permalink\",\n    className: \"header-links before\"\n  }, React.createElement(_components.div, {\n    dangerouslySetInnerHTML: {\n      __html: \"<svg aria-hidden=\\\"true\\\" focusable=\\\"false\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg>\"\n    }\n  })), \"노드의 저장공간을 Pod에서 활용하기: hostVolume\"), \"\\n\", React.createElement(_components.p, null, \"docker의 bind mount와 비슷한 메커니즘. 워커노드의 특정 디렉토리를 명시하여 이를 container의 디렉토리와 바인딩하며, 이는 양방향으로 동작하기에 호스트(워커노드)의 디렉토리 관리에 주의해야한다.\"), \"\\n\", React.createElement(_components.h2, {\n    id: \"persistent-volume-활용하기\",\n    style: {\n      position: \"relative\"\n    }\n  }, React.createElement(_components.a, {\n    href: \"#persistent-volume-%ED%99%9C%EC%9A%A9%ED%95%98%EA%B8%B0\",\n    \"aria-label\": \"persistent volume 활용하기 permalink\",\n    className: \"header-links before\"\n  }, React.createElement(_components.div, {\n    dangerouslySetInnerHTML: {\n      __html: \"<svg aria-hidden=\\\"true\\\" focusable=\\\"false\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg>\"\n    }\n  })), \"Persistent Volume 활용하기\"), \"\\n\", React.createElement(_components.p, null, \"Persistent Volume은 Pod가 필요한 Volume을 요청하여 사용할 수 있도록 \", React.createElement(_components.strong, null, \"cluster 레벨에서 제공하는 스토리지\"), \"이다. 따라서, Pod에 걸친 그리고 여러 노드에 걸쳐서도 데이터 영속성을 보장할 수 있는 방식이다.\"), \"\\n\", React.createElement(_components.p, null, \"cluster에는 다양한 타입의 storage가 연결될 수 있다. 네트워크로 연결된 NFS 드라이브가 연결될 수도 있으며, CSP에서 제공하는 블록 스토리지가 연결될 수도 있다.\"), \"\\n\", React.createElement(_components.p, null, \"Persistent Volume의 활용 메커니즘은 단순하다. 우선, 관리자는 cluster 레벨에서 공유될 저장공간인 Persistent Volume을 정의해야한다. 다음과 같다:\"), \"\\n\", React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-yaml\"\n  }, \"apiVersion: v1\\nkind: PersistentVolume\\nmetadata:\\n\\tname: my-pv001\\nspec:\\n\\tcapacity: \\n\\t\\tstorage: 10Gi\\n  storageClassName: my-storage\\n  volumeMode: Filesystem\\n  accessModes:\\n  - ReadWriteOnce\\n  persistentVolumeReclaimPolicy: Delete\\n  hostPath:\\n  \\tpath: /pv-test/pv001\\n\")), \"\\n\", React.createElement(_components.ul, null, \"\\n\", React.createElement(_components.li, null, \"\\n\", React.createElement(_components.p, null, \"10GB의 persistent volume을 정의한다.\"), \"\\n\"), \"\\n\", React.createElement(_components.li, null, \"\\n\", React.createElement(_components.p, null, React.createElement(_components.code, null, \"volumeMode\"), \" 를 통해 해당 volume이 Pod 속 container에 마운트될 때 container의 file system의 일부로 인식되도록 정의한다. 즉, container 내부의 디렉토리로 인식한다는 말이다.\"), \"\\n\"), \"\\n\", React.createElement(_components.li, null, \"\\n\", React.createElement(_components.p, null, React.createElement(_components.code, null, \"accessMode\"), \"를 통해 다수의 노드에서 접근하는 전략을 설정할 수 있다.\"), \"\\n\"), \"\\n\", React.createElement(_components.li, null, \"\\n\", React.createElement(_components.p, null, React.createElement(_components.code, null, \"persistentVolumeReclaimPolicy\"), \"를 통해 PV의 사용이 끝났을 때 해당 볼륨에 저장된 파일을 어떻게 처리할 것인지에 대한 정책을 정의한다.\"), \"\\n\"), \"\\n\"), \"\\n\", React.createElement(_components.blockquote, null, \"\\n\", React.createElement(_components.p, null, \"Persistent Volume은 정적으로 제공되는 공간이기에 Pod가 생성되기 이전에 미리 준비되어야 한다.\"), \"\\n\"), \"\\n\", React.createElement(_components.p, null, \"이제 Persistent Volume을 cluster 레벨에서 정의했으니, cluster 내의 Pod가 해당 스토리지를 활용할 수 있도록 연결해야한다. 이 때 스토리지를 원하는 Pod는 Persistent Volume Claim 오브젝트를 선언해서 kubernetes에게 ‘명세에 맞는 Persistent Volume 중 적당한 것을 달라’ 고 요청해야한다.\"), \"\\n\", React.createElement(_components.p, null, \"이 때, Persistent Volume의 특성에 대해 다시 생각해보자. PV는 kubernetes cluster 전체에 제공되는 \", React.createElement(_components.strong, null, \"추상화된 저장공간\"), \"이다. 따라서 Pod가 PV를 마운트하기 위해서는 \", React.createElement(_components.code, null, \"my-pv001\"), \"이라는 PV를 직접 지정하는 것이 아니라, Pod에 필요한 저장공간의 추상화된 속성을 열거하여 요청하는 것이다.\"), \"\\n\", React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-yaml\"\n  }, \"apiVersion: v1\\nkind: PersistentVolumeClaim\\nmetadata:\\n\\tname: my-pv-claim-01\\nspec:\\n\\tstorageClassName: my-storage\\n\\taccessModes:\\n\\t- ReadWriteOnce\\n\\tresources:\\n\\t\\trequests:\\n\\t\\t\\tstorage: 5Gi\\n\")), \"\\n\", React.createElement(_components.ul, null, \"\\n\", React.createElement(_components.li, null, \"5GiB 이상의 저장공간을 가지고 있으며, 하나의 노드에서만 읽고 쓸 수 있고 스토리지 클래스가 \", React.createElement(_components.code, null, \"my-storage\"), \"인 조건을 만족하는 Persistent Volume 중 적당한 것을 할당해줘\"), \"\\n\"), \"\\n\", React.createElement(_components.p, null, \"PVC는 kubernetes가 가장 적합한 PV를 찾아서 알아서 할당해준다. 이 때, \", React.createElement(_components.strong, null, \"PV와 PVC의 관계는 one-to-one\"), \" 이다. 즉, Persistent Volume Claim에 바운드된 Persistent Volume은 다른 Persistent Volume Claim에 동시에 바운드될 수 없다.\"), \"\\n\", React.createElement(_components.p, null, \"위의 예시를 보면, 10GiB의 PV가 있고 그 중에 5GiB 만큼의 PVC를 요청했다. ‘PV의 유휴 공간인 5GiB만큼 더 요청하는 PVC를 정의해도 되겠군’ 이라고 생각할 수 있지만, PVC와 PV는 1대1 매핑이므로 현재 가용 PV가 존재하지 않아 새로운 PVC 요청은 \", React.createElement(_components.code, null, \"pending\"), \" 상태에 머무르며 새로운 적당한 PV가 나타나기를 기다리게 된다.\"), \"\\n\", React.createElement(_components.p, null, \"아무튼 이제 PVC도 매핑되었으니, PVC로 요청한 스토리지를 실제 Pod에 마운트해주어야 한다.\"), \"\\n\", React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-yaml\"\n  }, \"apiVersion: v1\\nkind: Pod\\nmetadata: \\n\\tname: my-pod\\nspec:\\n\\tcontainers:\\n\\t\\t- name: my-container\\n\\t\\t\\timage: my-app:1.0.0\\n\\t\\t\\tvolumeMounts:\\n\\t\\t\\t\\t- name: my-pvc\\n\\t\\t\\t\\t\\tpersistentVolumeClaim:\\n\\t\\t\\t\\t\\t\\tclaimName: my-pv-claim-01\\n\")), \"\\n\", React.createElement(_components.p, null, \"Persistent Volume을 이용해서 Pod간, 노드간 데이터 영속성을 달성할 수 있었지만 PV는 특성상 정적으로 제공되는 저장공간이므로 불편한 점이 많다. PVC로 요청할 때 필요한 용량 보다 더 큰 용량을 가진 PV가 매핑될 수도 있으며, 모든 PV가 할당된 경우에는 PVC의 요청에도 계속 대기하고 있을 수 있다.\"), \"\\n\", React.createElement(_components.h2, {\n    id: \"storage-class로-동적할당하기\",\n    style: {\n      position: \"relative\"\n    }\n  }, React.createElement(_components.a, {\n    href: \"#storage-class%EB%A1%9C-%EB%8F%99%EC%A0%81%ED%95%A0%EB%8B%B9%ED%95%98%EA%B8%B0\",\n    \"aria-label\": \"storage class로 동적할당하기 permalink\",\n    className: \"header-links before\"\n  }, React.createElement(_components.div, {\n    dangerouslySetInnerHTML: {\n      __html: \"<svg aria-hidden=\\\"true\\\" focusable=\\\"false\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg>\"\n    }\n  })), \"Storage Class로 동적할당하기\"), \"\\n\", React.createElement(_components.p, null, \"스토리지를 동적으로 할당할 수 있다면 Pod의 볼륨에 대한 수요를 유연하게 처리할 수 있을 것이다. 스토리지가 필요한 시점에 필요한 만큼의 스토리지를 생성한 후, Pod에 할당하는 방식이다. Storage Class는 동적 프로비저닝을 위한 설정으로, 동적으로 스토리지를 할당하는 서비스를 제공하는 CSP의 솔루션을 연결해서 제공하는 방식이다.\"), \"\\n\", React.createElement(_components.blockquote, null, \"\\n\", React.createElement(_components.p, null, \"kubernetes에서 \", React.createElement(_components.em, null, \"영속성을 달성하기 위해 가장 많이 사용하는 방식은 Storage Class\"), \"이다.\"), \"\\n\"), \"\\n\", React.createElement(_components.p, null, \"StorageClass는 PV와 마찬가지로 사전에 정의되어있어야 한다. 하지만 PV와는 다르게 할당할 저장공간을 정의할 필요가 없으며 (동적으로 확장되므로) Storage Class는 PVC와 one-to-many 관계를 맺는다.\"), \"\\n\", React.createElement(_components.p, null, \"동적 프로비저닝이 가능한 대표적인 스토리지 서비스인 AWS의 EBS (Elastic Block Storage)를 예시로 정의해보자:\"), \"\\n\", React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-yaml\"\n  }, \"apiVersion: storage.k8s.io/v1\\nkind: StorageClass\\nmetadata:\\n\\tname: ebs-storage\\nprovisioner: kubernetes.io/aws-ebs\\nparameters:\\n\\ttype: gp2\\nreclaimPolicy: Retain\\nallowVolumeExpansion: true\\nvolumeBindingMode: Immediate\\n\")), \"\\n\", React.createElement(_components.ul, null, \"\\n\", React.createElement(_components.li, null, \"볼륨을 동적으로 확장할 수 있는 EBS 공간을 확보했다. (이미 생성된 볼륨을 축소하는 것은 허용되지 않는다)\"), \"\\n\", React.createElement(_components.li, null, \"이 StorageClass를 사용하는 PVC가 생성되면 바로 저장소를 생성해서 할당한다.\"), \"\\n\"), \"\\n\", React.createElement(_components.p, null, \"PV와 같이 해당 StorageClass도 사용하고자 할당을 요청하는 PVC를 정의해야한다.\"), \"\\n\", React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-yaml\"\n  }, \"apiVersion: v1\\nkind: PersistentVolumeClaim\\nmetadata:\\n\\tname: ebs-claim\\nspec:\\n\\taccessModes:\\n\\t\\t- ReadWriteOnce\\n  storageClassName: ebs-storage\\n  resources:\\n  \\trequests:\\n  \\t\\tstorage: 10Gi\\n\")), \"\\n\", React.createElement(_components.p, null, \"PVC에 원하는 저장공간이 할당되었다면, 해당 PVC를 Pod에 마운트하도록 정의해야한다. 방식은 PV 챕터에서 다룬 것과 동일하다.\"));\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? React.createElement(MDXLayout, props, React.createElement(_createMdxContent, props)) : _createMdxContent(props);\n}\nexport default MDXContent;\n","import GATSBY_COMPILED_MDX from \"/Users/leobang/blog-starter/documents/Docker/kubernetes-persistencty.md\";\nimport React from 'react';\nimport {graphql} from 'gatsby';\nimport ArticleLayout from 'components/Layout/ArticleLayout';\nimport MarkdownWrapper from 'components/MarkdownWrapper';\nimport ArticleFrontmatter from 'components/ArticleFrontmatter';\nimport ArticlePageContext from 'contexts/ArticlePageContext';\nimport Utterances from 'components/Utterance';\nimport RecentPosts from 'components/RecentPosts/RecentPosts';\nconst isBrowser = typeof window !== undefined;\nconst ArticlePage = ({data, children, serverData}) => {\n  const {prevPost, nextPost} = data;\n  const frontmatters = {\n    ...data.mdx.frontmatter,\n    timeToRead: data.mdx.fields.timeToRead\n  };\n  return React.createElement(ArticlePageContext, {\n    data: data\n  }, React.createElement(ArticleLayout, null, React.createElement(ArticleFrontmatter, frontmatters), React.createElement(MarkdownWrapper, null, children), React.createElement(RecentPosts, {\n    prev: prevPost,\n    next: nextPost\n  }), React.createElement(Utterances)));\n};\nArticlePage\nexport default function GatsbyMDXWrapper(props) {\n  return React.createElement(ArticlePage, props, React.createElement(GATSBY_COMPILED_MDX, props));\n}\nexport const query = graphql`\n  query ($id: String, $nextId: String, $prevId: String) {\n    mdx(id: { eq: $id }) {\n      id\n      fields {\n        slug\n        timeToRead\n        categoryDirectory\n      }\n      frontmatter {\n        title\n        createdAt(formatString: \"MMMM DD, YYYY\")\n      }\n      tableOfContents\n    }\n    prevPost: mdx(id: { eq: $prevId }) {\n      fields {\n        slug\n      }\n      frontmatter {\n        title\n      }\n    }\n    nextPost: mdx(id: { eq: $nextId }) {\n      fields {\n        slug\n      }\n      frontmatter {\n        title\n      }\n    }\n  }\n`;\nexport {ArticlePageHead as Head} from 'components/head';\n"],"names":["_createMdxContent","props","_components","Object","assign","p","ul","li","h2","a","div","strong","ol","pre","code","blockquote","em","_provideComponents","components","React","id","style","position","href","className","dangerouslySetInnerHTML","__html","wrapper","MDXLayout","ArticlePage","data","children","serverData","prevPost","nextPost","frontmatters","mdx","frontmatter","timeToRead","fields","ArticlePageContext","ArticleLayout","ArticleFrontmatter","MarkdownWrapper","RecentPosts","prev","next","Utterances","GatsbyMDXWrapper","GATSBY_COMPILED_MDX"],"sourceRoot":""}